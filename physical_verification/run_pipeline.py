# 이 파일은 전체 파이프라인(GLB 변환 -> 물리 검증 -> 구조 수정 -> 결과 저장)을 순차적으로 실행하는 스크립트입니다.
import os
import argparse
import time
from typing import List, Dict, Any

# 모듈 가져오기
from glb_to_ldr_quick import load_glb_meshes, build_under_budget, write_ldr
from pybullet_verifier import PyBulletVerifier
from structure_fixer import StructureFixer
from ldr_loader import LdrLoader

def run_pipeline(input_path: str, output_path: str, skip_gen: bool = False, gui: bool = False):
    print(f"=== {input_path} 파이프라인 시작 ===")
    
    current_ldr = input_path
    
    # 1. 생성 (GLB -> LDR)
    if not skip_gen:
        print("\n[1단계] GLB에서 LDR 생성 중...")
        meshes = load_glb_meshes(input_path)
        # 퀵 스크립트와 유사한 기본 설정 사용
        parts, final_target = build_under_budget(
            meshes,
            start_target=60,
            min_target=10,
            budget=100,
            shrink=0.85,
            search_iters=4,
            flipx180=False, flipy180=False, flipz180=False,
            fill=False, keep_connected=True,
            kind="brick", plates_per_voxel=3, interlock=True, max_area=20,
            solid_color=4, use_mesh_color=True, invert_y=False
        )
        
        current_ldr = "v0_generated.ldr"
        write_ldr(current_ldr, parts, title="AutoGenerated")
        print(f"-> {current_ldr} 생성됨 ({len(parts)}개 부품).")
    else:
        print(f"\n[1단계] 생성 건너뜀. 기존 LDR 사용: {current_ldr}")

    # 2. 수정 루프
    max_iterations = 3
    
    for i in range(max_iterations):
        print(f"\n[2단계 - 반복 {i+1}] 안정성 검증 중...")
        
        # 검증
        verifier = PyBulletVerifier(gui=gui) 
        
        # 시뮬레이션 로드 및 설정
        loader = LdrLoader()
        brick_plan = loader.load_from_file(current_ldr)
        verifier.load_bricks(brick_plan)
        
        # 확인 실행
        result = verifier.run_stability_check(duration=2.0)
        # verifier.cleanup()은 run_stability_check 내부에서 처리되거나 필요하지 않음
        
        if result.is_valid:
            print(f"\n✅ 성공! 모델이 안정적입니다.")
            print(f"최종 출력: {current_ldr}")
            # 요청한 출력 경로로 복사
            if output_path != current_ldr:
                import shutil
                shutil.copy(current_ldr, output_path)
            return

        print(f"❌ 실패. 안정성 점수: {result.score}")
        
        # 최초 실패 분석
        first_failure_id = None
        for ev in result.evidence:
            if ev.type == "FIRST_FAILURE":
                # 메시지 형식: "Structural collapse started at {id}..."
                # 가능한 경우 brick_ids 목록에서 ID 추출
                if ev.brick_ids:
                    first_failure_id = ev.brick_ids[0]
                break
        
        if not first_failure_id:
            print("구체적인 실패 지점을 식별할 수 없습니다. 중단합니다.")
            break
            
        print(f"-> 실패 시작 지점 감지: {first_failure_id}")
        
        # 수정
        print(f"[3단계 - 반복 {i+1}] 수정 적용 중...")
        fixer = StructureFixer(current_ldr)
        
        failure_report = {
            "fallen": True,
            "first_failure_id": first_failure_id
        }
        
        fixes = fixer.analyze_failure(failure_report)
        if not fixes:
            print("이 실패 유형에 대해 사용 가능한 자동 수정이 없습니다.")
            break
            
        applied_count = 0
        for fix in fixes:
            if fixer.apply_fix(fix):
                applied_count += 1
                
        if applied_count == 0:
            print("수정을 적용하지 못했습니다.")
            break
            
        # 수정된 LDR 저장
        next_ldr = f"v{i+1}_fixed.ldr"
        fixer.save_fixed_ldr(next_ldr)
        current_ldr = next_ldr
        print(f"-> 보강된 모델을 {current_ldr}에 저장했습니다")

    print("\n⚠️ 최대 반복 횟수에 도달했거나 수정에 실패했습니다.")
    print(f"마지막 시도: {current_ldr}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("input_path", help="입력 GLB 또는 LDR 파일 경로")
    parser.add_argument("--out", default="final_model.ldr", help="출력 경로")
    parser.add_argument("--skip-gen", action="store_true", help="생성 건너뛰기, 입력을 LDR로 처리")
    parser.add_argument("--gui", action="store_true", help="시각적 검증을 위해 PyBullet GUI 표시")
    args = parser.parse_args()
    
    run_pipeline(args.input_path, args.out, skip_gen=args.skip_gen, gui=args.gui)
