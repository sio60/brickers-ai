import os
import argparse
import time
from typing import List, Dict, Any

# Import our modules
from glb_to_ldr_quick import load_glb_meshes, build_under_budget, write_ldr
from pybullet_verifier import PyBulletVerifier
from structure_fixer import StructureFixer
from ldr_loader import LdrLoader

def run_pipeline(input_path: str, output_path: str, skip_gen: bool = False, gui: bool = False):
    print(f"=== Starting Pipeline for {input_path} ===")
    
    current_ldr = input_path
    
    # 1. Generation (GLB -> LDR)
    if not skip_gen:
        print("\n[Phase 1] Generating LDR from GLB...")
        meshes = load_glb_meshes(input_path)
        # Use default settings similar to quick script
        parts, final_target = build_under_budget(
            meshes,
            start_target=60,
            min_target=10,
            budget=100,
            shrink=0.85,
            search_iters=4,
            flipx180=False, flipy180=False, flipz180=False,
            fill=False, keep_connected=True,
            kind="brick", plates_per_voxel=3, interlock=True, max_area=20,
            solid_color=4, use_mesh_color=True, invert_y=False
        )
        
        current_ldr = "v0_generated.ldr"
        write_ldr(current_ldr, parts, title="AutoGenerated")
        print(f"-> Generated {current_ldr} with {len(parts)} parts.")
    else:
        print(f"\n[Phase 1] Skipping Generation. Using existing LDR: {current_ldr}")

    # 2. Fix Loop
    max_iterations = 3
    
    for i in range(max_iterations):
        print(f"\n[Phase 2 - Iteration {i+1}] Verifying Stability...")
        
        # Verify
        verifier = PyBulletVerifier(gui=gui) 
        
        # Load and set up simulation
        loader = LdrLoader()
        brick_plan = loader.load_from_file(current_ldr)
        verifier.load_bricks(brick_plan)
        
        # Run check
        result = verifier.run_stability_check(duration=2.0)
        # verifier.cleanup() is handled inside run_stability_check or not needed
        
        if result.is_valid:
            print(f"\n✅ SUCCESS! Model is stable.")
            print(f"Final output: {current_ldr}")
            # Copy to requested output path
            if output_path != current_ldr:
                import shutil
                shutil.copy(current_ldr, output_path)
            return

        print(f"❌ FAIL. Stability score: {result.score}")
        
        # Parse First Failure
        first_failure_id = None
        for ev in result.evidence:
            if ev.type == "FIRST_FAILURE":
                # Message format: "Structural collapse started at {id}..."
                # Extract ID from brick_ids list if available
                if ev.brick_ids:
                    first_failure_id = ev.brick_ids[0]
                break
        
        if not first_failure_id:
            print("Could not identify specific failure point. Stopping.")
            break
            
        print(f"-> Detected failure starting at: {first_failure_id}")
        
        # Fix
        print(f"[Phase 3 - Iteration {i+1}] Applying Fixes...")
        fixer = StructureFixer(current_ldr)
        
        failure_report = {
            "fallen": True,
            "first_failure_id": first_failure_id
        }
        
        fixes = fixer.analyze_failure(failure_report)
        if not fixes:
            print("No automated fixes available for this failure type.")
            break
            
        applied_count = 0
        for fix in fixes:
            if fixer.apply_fix(fix):
                applied_count += 1
                
        if applied_count == 0:
            print("Failed to apply any fixes.")
            break
            
        # Save fixed LDR
        next_ldr = f"v{i+1}_fixed.ldr"
        fixer.save_fixed_ldr(next_ldr)
        current_ldr = next_ldr
        print(f"-> Saved reinforced model to {current_ldr}")

    print("\n⚠️ Maximum iterations reached or fix failed.")
    print(f"Last attempt: {current_ldr}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("input_path", help="Path to input GLB or LDR file")
    parser.add_argument("--out", default="final_model.ldr", help="Output path")
    parser.add_argument("--skip-gen", action="store_true", help="Skip generation, input is treated as LDR")
    parser.add_argument("--gui", action="store_true", help="Show PyBullet GUI for visual verification")
    args = parser.parse_args()
    
    run_pipeline(args.input_path, args.out, skip_gen=args.skip_gen, gui=args.gui)
