기존 물리 검증 시스템(AABB 기반) 코드 상세 분석

이 보고서는 physical_verification 모듈의 모든 로직을 코드 레벨에서 낱낱이 파악하여, PyBullet 전환 전 "무엇이 어떻게 돌아가고 있었는지"를 완벽히 이해하기 위해 작성되었습니다.

---

1. 데이터 파이프라인 (LDR → BrickPlan)

[A] ldr_loader.py: 좌표의 탄생
1. 파싱: LDR 파일의 각 라인(1 <color> x y z a b c d e f g h i <part>)을 읽습니다.
2. 행렬 연산: 3x3 회전 행렬(a~i)을 사용해 브릭의 방향을 결정합니다.
3. AABB 팽창 문제: 
   - get_part_dims에서 파트의 로컬 최소/최대 좌표를 가져옵니다.
   - 브릭이 회전되어 있으면, 회전된 8개 꼭짓점을 모두 감싸는 새로운 최소/최대 박스를 계산합니다.
   - 결과: 45도 회전된 1x1 브릭은 실제보다 약 1.4배 큰 박스가 되어버립니다.

---

2. 5대 핵심 검증 로직 상세

① verify_floating: 연결성 그래프 검사
* 알고리즘: Graph-based Connectivity
* 코드 원리:
  1. 모든 브릭을 노드(Node)로 생성합니다.
  2. _are_connected(b1, b2)가 True이면 두 노드 사이에 엣지(Edge)를 긋습니다.
  3. z=0에 닿아있는 브릭들을 'Ground Nodes'로 지정합니다.
  4. 판정: Ground Nodes와 연결되지 않은(Path가 없는) 섬 같은 노드들은 Floating으로 판정합니다.
* 한계: AABB가 겹쳐야만 연결된 것으로 보므로, 아주 살짝 떨어진 정교한 결합을 놓칠 수 있습니다.

② verify_collision: 부피 중첩 검사
* 알고리즘: Box-Box Intersection Volume
* 코드 원리:
  1. 두 브릭 박스가 겹치는 영역(Overlap Box)의 부피를 계산합니다.
  2. (겹친 부피) / (더 작은 브릭의 부피) 비율을 구합니다.
  3. 판정: 이 비율이 10%를 넘으면 "충돌"로 봅니다.
* 특이사항 (기계 파트 예외): 
  - 파트 이름에 wheel, tire, rim, technic 등이 들어가면 허용치를 85%로 높여버립니다. 
  - 결과: car.ldr 머드가드 사례처럼 예외 키워드에 없는 파트는 억울하게 0점 처리가 됩니다.

③ verify_stability: 무게 중심과 지지 면적
* 알고리즘: Center of Mass (COM) inside Convex Hull
* 코드 원리:
  1. 연결된 덩어리(Connected Component)별로 무게 중심을 계산합니다.
  2. 해당 덩어리가 바닥(또는 아래층 브릭)과 맞닿은 점들을 모아 Convex Hull(최소 볼록 다각형)을 만듭니다.
  3. 판정: 무게 중심에서 수직으로 내린 선이 이 다각형 '안'에 들어오면 안정, '밖'으로 나가면 전도로 판정합니다.
* 한계: 정적인 계산이라, 흔들림이나 동적인 힘을 계산하지 못합니다.

④ verify_connection_strength: 1-스터드 검사
* 코드 원리:
  1. 두 브릭이 위아래로 닿아있을 때, 겹치는 면의 넓이를 계산합니다.
  2. 레고 1개 스터드의 표준 면적(약 256 LDU^2)과 비교합니다.
  3. 판정: 겹친 면적이 스터드 1개 정도밖에 안 되면 "회전하기 쉽다"고 보고 경고를 줍니다.

⑤ verify_overhang: 캔틸레버 검사
* 코드 원리:
  1. 어떤 브릭 아래에 아무것도 없는 영역이 얼마나 되는지 계산합니다.
  2. 판정: 브릭 바닥면의 70% 이상이 허공에 떠 있으면 "무너질 위험이 있다"고 판정합니다.

---

3. part_library.py: 치수 데이터의 마법
* DB 연동: MongoDB의 parts 컬렉션에서 min_x, max_x... 데이터를 가져옵니다.
* 로컬 폴백: 만약 DB에 데이터가 없으면, 로컬에 있는 LDraw .dat 파일을 직접 열어서 1번 라인(하위 부품)을 뒤져 좌표를 계산해냅니다 (상당히 복잡한 재귀 로직).

---

4. PyBullet으로 가면 무엇이 '삭제'되는가?

1. verify_collision의 복잡한 수학: PyBullet이 알아서 해줍니다.
2. verify_floating의 그래프 로직: 시뮬레이션 돌려서 떨어지면 부유물입니다. 더 직관적입니다.
3. _are_connected의 오차 보정: 실제 메시가 닿았는지를 보므로 TOL = 0.05 같은 임의의 수치가 필요 없습니다.

---

결론: 현재 시스템은 "박스들의 기하학적 겹침을 수학적으로 처리하는 계산기"에 가깝습니다. PyBullet은 이를 "실제 질량을 가진 물체들의 상호작용"으로 바꿔줄 것입니다.
