<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§± Brick Judge 3D Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        #viewer {
            flex: 1;
            
            position: relative;
        }

        #canvas {
            width: 100%;
            height: 100%;
        }

        .sidebar {
            width: 320px;
            background: #16213e;
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #0f3460;
        }

        h1 {
            font-size: 1.4rem;
            margin-bottom: 20px;
            color: #e94560;
        }

        h2 {
            font-size: 1rem;
            margin: 20px 0 10px;
            color: #0f4c75;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 5px;
        }

        .upload-area {
            border: 2px dashed #0f4c75;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            border-color: #e94560;
            background: rgba(233, 69, 96, 0.1);
        }

        .upload-area input {
            display: none;
        }

        .btn {
            background: #e94560;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            width: 100%;
            margin-top: 10px;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #ff6b6b;
        }

        .btn:disabled {
            background: #555;
            cursor: not-allowed;
        }

        .stats {
            background: #0f3460;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .stats-label {
            color: #888;
        }

        .stats-value {
            font-weight: bold;
        }

        .score {
            font-size: 2rem;
            text-align: center;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .score.stable {
            background: linear-gradient(135deg, #1d976c, #93f9b9);
            color: #000;
        }

        .score.unstable {
            background: linear-gradient(135deg, #e94560, #ff6b6b);
        }

        .issue-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .issue-item {
            background: #0f3460;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 4px solid;
        }

        .issue-item:hover {
            transform: translateX(5px);
        }

        .issue-item.critical {
            border-color: #e94560;
        }

        .issue-item.high {
            border-color: #ff9800;
        }

        .issue-item.medium {
            border-color: #ffc107;
        }

        .issue-item.low {
            border-color: #4caf50;
        }

        .issue-type {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: #888;
        }

        .issue-msg {
            margin-top: 5px;
            font-size: 0.9rem;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8rem;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #0f3460;
            border-top-color: #e94560;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .hidden {
            display: none;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 0.85rem;
        }

        textarea {
            width: 100%;
            height: 120px;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            border-radius: 6px;
            color: #eee;
            padding: 10px;
            font-family: monospace;
            font-size: 0.8rem;
            resize: vertical;
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="viewer">
            <div id="canvas"></div>
            <div id="info">ë§ˆìš°ìŠ¤: íšŒì „ | ìŠ¤í¬ë¡¤: ì¤Œ | Shift+ë“œë˜ê·¸: ì´ë™</div>
            <div id="loading" class="loading hidden">
                <div class="spinner"></div>
                <p style="margin-top: 15px;">LDR ë¡œë”© ì¤‘...</p>
            </div>
        </div>

        <div class="sidebar">
            <h1>ğŸ§± Brick Judge 3D</h1>

            <div class="upload-area" onclick="document.getElementById('ldrFile').click()">
                <input type="file" id="ldrFile" accept=".ldr,.mpd,.dat">
                <p>ğŸ“ LDR íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”</p>
                <p style="font-size: 0.8rem; color: #888; margin-top: 5px;">ë˜ëŠ” ë“œë˜ê·¸ ì•¤ ë“œë¡­</p>
            </div>

            <h2>ğŸ“ ë˜ëŠ” LDR ì§ì ‘ ì…ë ¥</h2>
            <textarea id="ldrText" placeholder="0 My Model
1 4 0 0 0 1 0 0 0 1 0 0 0 1 3001.dat
1 1 0 -24 0 1 0 0 0 1 0 0 0 1 3003.dat"></textarea>
            <button class="btn" id="analyzeBtn">ğŸ” ë¶„ì„í•˜ê¸°</button>

            <div id="resultPanel" class="hidden">
                <h2>ğŸ“Š ë¶„ì„ ê²°ê³¼</h2>

                <div id="scoreBox" class="score stable">
                    <div id="scoreValue">100</div>
                    <div style="font-size: 0.9rem;">ì </div>
                </div>

                <div class="stats">
                    <div class="stats-row">
                        <span class="stats-label">ë¸Œë¦­ ìˆ˜</span>
                        <span class="stats-value" id="totalBricks">0</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">ë¬¸ì œ ìˆ˜</span>
                        <span class="stats-value" id="issueCount">0</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">ì•ˆì •ì„±</span>
                        <span class="stats-value" id="stability">-</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">ë°±ì—”ë“œ</span>
                        <span class="stats-value" id="backendInfo">-</span>
                    </div>
                </div>

                <h2>ğŸ¨ ìƒ‰ìƒ ë²”ë¡€</h2>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #0055FF;"></div>
                        <span>TOP_ONLY (ìœ„ì—ì„œë§Œ ê²°í•©)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF0000;"></div>
                        <span>FLOATING (ê³µì¤‘ì— ë– ìˆìŒ)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FFCC00;"></div>
                        <span>ISOLATED (ì—°ê²° ì—†ìŒ)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4caf50;"></div>
                        <span>ì •ìƒ</span>
                    </div>
                </div>

                <h2>âš ï¸ ë°œê²¬ëœ ë¬¸ì œ</h2>
                <div id="issueList" class="issue-list"></div>

                <button class="btn" id="tourBtn" style="background: #e94560; margin-top: 20px;">
                    â–¶ï¸ ìë™ íˆ¬ì–´
                </button>
                <button class="btn" id="stopTourBtn" style="background: #555; margin-top: 5px; display: none;">
                    â¹ï¸ íˆ¬ì–´ ì¤‘ì§€
                </button>
                <div id="tourProgress" style="display: none; margin-top: 10px; text-align: center; color: #aaa;">
                    <span id="tourCurrent">0</span> / <span id="tourTotal">0</span>
                </div>
                <button class="btn" id="blinkAllBtn" style="background: #ff5722; margin-top: 10px;">
                    âš¡ ì „ì²´ ë¶ˆëŸ‰ ê¹œë¹¡ì„
                </button>

                <button class="btn" id="comSimBtn" style="background: #9c27b0; margin-top: 20px;">
                    âš–ï¸ ë¬´ê²Œì¤‘ì‹¬ ì‹œë®¬ë ˆì´ì…˜
                </button>
                <button class="btn" id="physicsBtn" style="background: #ff9800; margin-top: 5px;">
                    ğŸ’¥ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ (ë¶•ê´´)
                </button>
                <button class="btn" id="resetBtn" style="background: #0f4c75; margin-top: 5px;">
                    ğŸ”„ ë¦¬ì…‹
                </button>
                <button class="btn" id="explodeFloatingBtn" style="background: #FF5722; margin-top: 20px;">
                    ğŸ’¥ Floating ë¸Œë¦­ ë¶„í•´
                </button>
                <button class="btn" id="mergeFloatingBtn" style="background: #2196F3; margin-top: 5px;">
                    ğŸ”— ë¶ˆì•ˆì • ë¸Œë¦­ ë³‘í•©
                </button>
                <button class="btn" id="autoRepairBtn" style="background: #4CAF50; margin-top: 5px;">
                    ğŸ”§ ìë™ ìˆ˜ë¦¬ (ë¶„í•´â†’ë³‘í•© ë°˜ë³µ)
                </button>
                <div id="mergeResult"
                    style="margin-top: 10px; padding: 10px; background: #0f3460; border-radius: 6px; display: none;">
                    <span id="mergeResultText"></span>
                </div>
            </div>
        </div>
    </div>

    <!-- ES Module imports -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { LDrawLoader } from 'three/addons/loaders/LDrawLoader.js';

        // ============================================
        // Three.js ì„¤ì •
        // ============================================
        let scene, camera, renderer, controls;
        let model = null;
        let brickMeshes = new Map();

        const LDRAW_PATH = 'https://raw.githubusercontent.com/gkjohnson/ldraw-parts-library/master/complete/ldraw/';

        const ISSUE_COLORS = {
            floating: 0xe94560,
            unstable_base: 0xff9800,
            isolated: 0xffc107,
            weak: 0x4caf50,
            off_balance: 0x9c27b0,
        };

        function initThree() {
            const container = document.getElementById('canvas');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            camera = new THREE.PerspectiveCamera(
                45,
                container.clientWidth / container.clientHeight,
                1,
                10000
            );
            camera.position.set(150, 200, 250);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;

            // ì¡°ëª…
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 200, 100);
            scene.add(dirLight);

            // ê·¸ë¦¬ë“œ
            const gridHelper = new THREE.GridHelper(500, 50, 0x0f4c75, 0x0f3460);
            scene.add(gridHelper);

            // ì¶•
            const axesHelper = new THREE.AxesHelper(100);
            scene.add(axesHelper);

            window.addEventListener('resize', onResize);
            animate();
        }

        function onResize() {
            const container = document.getElementById('canvas');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // ============================================
        // LDR ë¡œë”
        // ============================================
        async function loadLDR(ldrContent) {
            showLoading(true);

            if (model) {
                scene.remove(model);
                model = null;
            }
            brickMeshes.clear();

            return new Promise((resolve, reject) => {
                const loader = new LDrawLoader();
                loader.setPartsLibraryPath(LDRAW_PATH);
                loader.smoothNormals = false;

                loader.parse(ldrContent, (group) => {
                    model = group;
                    model.rotation.x = Math.PI;  // LDraw ì¢Œí‘œê³„ ë’¤ì§‘ê¸°

                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());

                    // X, ZëŠ” ì¤‘ì‹¬ ì •ë ¬, YëŠ” ë°”ë‹¥ì´ ê·¸ë¦¬ë“œ(Y=0)ì— ì˜¤ë„ë¡
                    model.position.x = -center.x;
                    model.position.z = -center.z;
                    model.position.y = -box.min.y;  // ë°”ë‹¥ì„ Y=0ì— ë§ì¶¤

                    let brickId = 0;
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.userData.brickId = brickId;
                            child.userData.originalMaterial = child.material;
                            brickMeshes.set(brickId, child);
                            brickId++;
                        }
                    });

                    scene.add(model);

                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    camera.position.set(maxDim, maxDim * 1.5, maxDim * 2);
                    controls.target.set(0, size.y / 2, 0);
                    controls.update();

                    showLoading(false);
                    resolve(brickId);
                },
                    undefined,
                    (error) => {
                        showLoading(false);
                        reject(error);
                    });
            });
        }

        // ============================================
        // Brick Judge (ê°„ë‹¨ ë²„ì „)
        // ============================================
        function judgeBricks(ldrContent) {
            const lines = ldrContent.split('\n');
            const bricks = [];
            const issues = [];

            let brickId = 0;
            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('0')) continue;

                if (trimmed.startsWith('1 ')) {
                    const parts = trimmed.split(/\s+/);
                    if (parts.length >= 15) {
                        const color = parseInt(parts[1]);
                        const x = parseFloat(parts[2]);
                        const y = parseFloat(parts[3]);
                        const z = parseFloat(parts[4]);
                        // íšŒì „ í–‰ë ¬: a b c / d e f / g h i
                        const rotA = parseFloat(parts[5]);
                        const rotC = parseFloat(parts[7]);
                        const part = parts[14];

                        // 90ë„ íšŒì „ ê°ì§€ (aâ‰ˆ0, câ‰ˆÂ±1 ì´ë©´ íšŒì „ë¨)
                        const isRotated = Math.abs(rotA) < 0.5 && Math.abs(rotC) > 0.5;

                        bricks.push({
                            id: brickId,
                            color, x, y, z, part,
                            height: -y,
                            isRotated  // íšŒì „ ì—¬ë¶€ ì €ì¥
                        });
                        brickId++;
                    }
                }
            }

            // ë¸Œë¦­ í¬ê¸° (LDU ë‹¨ìœ„)
            const PART_SIZE = {
                '3001.dat': { w: 80, d: 40, h: 24 },  // 2x4
                '3002.dat': { w: 60, d: 40, h: 24 },  // 2x3
                '3003.dat': { w: 40, d: 40, h: 24 },  // 2x2
                '3004.dat': { w: 40, d: 20, h: 24 },  // 1x2
                '3005.dat': { w: 20, d: 20, h: 24 },  // 1x1
                '3008.dat': { w: 160, d: 20, h: 24 }, // 1x8
                '3009.dat': { w: 120, d: 20, h: 24 }, // 1x6
                '3010.dat': { w: 80, d: 20, h: 24 },  // 1x4
                '3622.dat': { w: 60, d: 20, h: 24 },  // 1x3
                '3007.dat': { w: 160, d: 40, h: 24 }, // 2x8
                '3006.dat': { w: 120, d: 40, h: 24 }, // 2x6
                '3020.dat': { w: 80, d: 40, h: 8 },   // plate 2x4
                '3021.dat': { w: 60, d: 40, h: 8 },   // plate 2x3
                '3022.dat': { w: 40, d: 40, h: 8 },   // plate 2x2
                '3023.dat': { w: 40, d: 20, h: 8 },   // plate 1x2
                '3024.dat': { w: 20, d: 20, h: 8 },   // plate 1x1
                '3460.dat': { w: 160, d: 20, h: 8 },  // plate 1x8
                '3666.dat': { w: 120, d: 20, h: 8 },  // plate 1x6
                '3710.dat': { w: 80, d: 20, h: 8 },   // plate 1x4
                '3623.dat': { w: 60, d: 20, h: 8 },   // plate 1x3
            };

            // ì‹¤ì œ ë¸Œë¦­ ë¬´ê²Œ (g) - Luo et al. "Legolization" ë…¼ë¬¸ ë°ì´í„°
            const BRICK_WEIGHT = {
                '3005.dat': 0.44,  // 1x1
                '3004.dat': 0.78,  // 1x2
                '3622.dat': 1.18,  // 1x3
                '3010.dat': 1.74,  // 1x4
                '3009.dat': 2.40,  // 1x6
                '3008.dat': 3.08,  // 1x8
                '3003.dat': 1.18,  // 2x2
                '3002.dat': 1.78,  // 2x3
                '3001.dat': 2.20,  // 2x4
                '3006.dat': 3.30,  // 2x6
                '3007.dat': 4.40,  // 2x8
                // PlateëŠ” ë¸Œë¦­ì˜ 1/3 ë†’ì´ â†’ ë¬´ê²Œë„ ì•½ 1/3
                '3024.dat': 0.15,  // plate 1x1
                '3023.dat': 0.26,  // plate 1x2
                '3623.dat': 0.39,  // plate 1x3
                '3710.dat': 0.58,  // plate 1x4
                '3666.dat': 0.80,  // plate 1x6
                '3460.dat': 1.03,  // plate 1x8
                '3022.dat': 0.39,  // plate 2x2
                '3021.dat': 0.59,  // plate 2x3
                '3020.dat': 0.73,  // plate 2x4
            };
            // 1ìŠ¤í„°ë“œ ìµœëŒ€ ë§ˆì°° í•˜ì¤‘ (g) - ë…¼ë¬¸ ì‹¤ì¸¡ê°’
            const MAX_FRICTION_LOAD = 71.658;

            const getWeight = (part) => BRICK_WEIGHT[part] || 1.0;  // ê¸°ë³¸ 1g
            // íšŒì „ ê³ ë ¤í•œ í¬ê¸° ë°˜í™˜
            const getSize = (part, isRotated = false) => {
                const size = PART_SIZE[part] || { w: 40, d: 40, h: 24 };
                // 90ë„ íšŒì „ ì‹œ wì™€ d êµí™˜
                if (isRotated) {
                    return { w: size.d, d: size.w, h: size.h };
                }
                return size;
            };

            // ë‘ ë¸Œë¦­ì˜ XZ í‰ë©´ ê²¹ì¹¨ ì—¬ë¶€ (ì˜ì—­ ê¸°ë°˜, íšŒì „ ê³ ë ¤)
            function hasXZOverlap(b1, b2) {
                const s1 = getSize(b1.part, b1.isRotated);
                const s2 = getSize(b2.part, b2.isRotated);

                const b1_minX = b1.x - s1.w / 2;
                const b1_maxX = b1.x + s1.w / 2;
                const b1_minZ = b1.z - s1.d / 2;
                const b1_maxZ = b1.z + s1.d / 2;

                const b2_minX = b2.x - s2.w / 2;
                const b2_maxX = b2.x + s2.w / 2;
                const b2_minZ = b2.z - s2.d / 2;
                const b2_maxZ = b2.z + s2.d / 2;

                // ê²¹ì¹¨ = ë‘ ì˜ì—­ì´ êµì°¨
                const xOverlap = b1_minX < b2_maxX && b1_maxX > b2_minX;
                const zOverlap = b1_minZ < b2_maxZ && b1_maxZ > b2_minZ;

                return xOverlap && zOverlap;
            }

            // ì—°ê²° ê·¸ë˜í”„ êµ¬ì¶• (ìœ„/ì•„ë˜ ìŠ¤í„°ë“œ ì—°ê²°)
            const connections = new Map();
            for (const brick of bricks) {
                connections.set(brick.id, new Set());
            }

            for (const brick of bricks) {
                const brickSize = getSize(brick.part, brick.isRotated);

                for (const other of bricks) {
                    if (other.id === brick.id) continue;

                    const otherSize = getSize(other.part, other.isRotated);

                    // XZ í‰ë©´ì—ì„œ ì˜ì—­ ê²¹ì¹¨ í™•ì¸
                    if (!hasXZOverlap(brick, other)) continue;

                    // ì•„ë˜ì—ì„œ ì§€ì§€ (otherì˜ ìœ—ë©´ = brickì˜ ë°”ë‹¥)
                    const otherTop = other.y - otherSize.h;
                    if (Math.abs(otherTop - brick.y) < 5) {
                        connections.get(brick.id).add(other.id);
                        connections.get(other.id).add(brick.id);
                    }

                    // ìœ„ì—ì„œ ì—°ê²° (brickì˜ ìœ—ë©´ = otherì˜ ë°”ë‹¥)
                    const brickTop = brick.y - brickSize.h;
                    if (Math.abs(brickTop - other.y) < 5) {
                        connections.get(brick.id).add(other.id);
                        connections.get(other.id).add(brick.id);
                    }
                }
            }

            // ë°”ë‹¥ ë¸Œë¦­ ì°¾ê¸° (ê°€ì¥ í° Yê°’ = LDrawì—ì„œ ë°”ë‹¥)
            const maxY = Math.max(...bricks.map(b => b.y));
            const groundBricks = new Set(bricks.filter(b => b.y >= maxY - 10).map(b => b.id));
            console.log(`ë°”ë‹¥ Y: ${maxY}, ë°”ë‹¥ ë¸Œë¦­ ìˆ˜: ${groundBricks.size}`);

            // BFSë¡œ ë°”ë‹¥ê³¼ ì—°ê²°ëœ ë¸Œë¦­ ì°¾ê¸°
            const connectedToGround = new Set();
            const queue = [...groundBricks];
            while (queue.length > 0) {
                const current = queue.shift();
                if (connectedToGround.has(current)) continue;
                connectedToGround.add(current);
                for (const neighbor of connections.get(current) || []) {
                    if (!connectedToGround.has(neighbor)) {
                        queue.push(neighbor);
                    }
                }
            }

            // ë¸Œë¦­ í¬ê¸° ì •ë³´ (ìŠ¤í„°ë“œ ê°œìˆ˜ ì¶”ì •)
            const PART_STUDS = {
                '3005.dat': 1,  // 1x1
                '3004.dat': 2,  // 1x2
                '3622.dat': 3,  // 1x3
                '3010.dat': 4,  // 1x4
                '3009.dat': 6,  // 1x6
                '3008.dat': 8,  // 1x8
                '3003.dat': 4,  // 2x2
                '3002.dat': 6,  // 2x3
                '3001.dat': 8,  // 2x4
                '3006.dat': 12, // 2x6
                '3007.dat': 16, // 2x8
                '3024.dat': 1,  // plate 1x1
                '3023.dat': 2,  // plate 1x2
                '3623.dat': 3,  // plate 1x3
                '3710.dat': 4,  // plate 1x4
                '3666.dat': 6,  // plate 1x6
                '3460.dat': 8,  // plate 1x8
                '3022.dat': 4,  // plate 2x2
                '3021.dat': 6,  // plate 2x3
                '3020.dat': 8,  // plate 2x4
            };
            const getStuds = (part) => PART_STUDS[part] || 1;

            // ê²°í•© ê°•ë„ ê³„ì‚° (ê²¹ì¹˜ëŠ” ìŠ¤í„°ë“œ ë©´ì , íšŒì „ ê³ ë ¤)
            function calcConnectionStrength(brick1, brick2) {
                const s1 = getSize(brick1.part, brick1.isRotated);
                const s2 = getSize(brick2.part, brick2.isRotated);

                // ê° ë¸Œë¦­ì˜ ê²½ê³„ ê³„ì‚°
                const b1_minX = brick1.x - s1.w / 2;
                const b1_maxX = brick1.x + s1.w / 2;
                const b1_minZ = brick1.z - s1.d / 2;
                const b1_maxZ = brick1.z + s1.d / 2;

                const b2_minX = brick2.x - s2.w / 2;
                const b2_maxX = brick2.x + s2.w / 2;
                const b2_minZ = brick2.z - s2.d / 2;
                const b2_maxZ = brick2.z + s2.d / 2;

                // ê²¹ì¹˜ëŠ” ì˜ì—­ ê³„ì‚°
                const overlapX = Math.max(0, Math.min(b1_maxX, b2_maxX) - Math.max(b1_minX, b2_minX));
                const overlapZ = Math.max(0, Math.min(b1_maxZ, b2_maxZ) - Math.max(b1_minZ, b2_minZ));

                // ìŠ¤í„°ë“œ ë‹¨ìœ„ë¡œ ë³€í™˜ (20 LDU = 1 ìŠ¤í„°ë“œ)
                const studOverlap = Math.floor((overlapX * overlapZ) / 400);
                return Math.max(1, studOverlap);  // ìµœì†Œ 1
            }

            // ìœ„ì—ì„œ ë§¤ë‹¬ë¦° ë¸Œë¦­ ë¬´ê²Œ ê³„ì‚° (BFSë¡œ í•˜ìœ„ ë¸Œë¦­ í•©ì‚°) - ì‹¤ì œ ê·¸ë¨ ë‹¨ìœ„
            function calcHangingWeight(brickId, visited = new Set()) {
                if (visited.has(brickId)) return 0;
                visited.add(brickId);

                const brick = bricks.find(b => b.id === brickId);
                if (!brick) return 0;

                let weight = getWeight(brick.part); // ìê¸° ë¬´ê²Œ (ê·¸ë¨)

                // ì•„ë˜ì— ì—°ê²°ëœ ë¸Œë¦­ë“¤ì˜ ë¬´ê²Œ í•©ì‚°
                for (const otherId of connections.get(brickId) || []) {
                    const other = bricks.find(b => b.id === otherId);
                    if (other && other.y < brick.y) { // ì•„ë˜ì— ìˆëŠ” ë¸Œë¦­
                        weight += calcHangingWeight(otherId, visited);
                    }
                }
                return weight;
            }

            // ë¬¼ë¦¬ ê²€ì‚¬
            for (const brick of bricks) {
                // ë°”ë‹¥ì— ìˆìœ¼ë©´ OK
                if (brick.y >= -10) continue;

                // ë°”ë‹¥ê³¼ ì—°ê²°ë˜ì§€ ì•Šì€ ë¸Œë¦­ = FLOATING
                if (!connectedToGround.has(brick.id)) {
                    issues.push({
                        brick_id: brick.id,
                        type: 'floating',
                        severity: 'critical',
                        message: `ë¸Œë¦­ #${brick.id} (${brick.part}) ë°”ë‹¥ê³¼ ì—°ê²° ì•ˆë¨ - ë†’ì´ ${brick.height.toFixed(0)} LDU`
                    });
                    continue;
                }

                const brickSize = getSize(brick.part, brick.isRotated);

                // ì•„ë˜ì—ì„œ ì§€ì§€ë°›ëŠ” ë¸Œë¦­ ì°¾ê¸°
                const supportFromBelow = bricks.some(other => {
                    if (other.id === brick.id) return false;
                    const otherSize = getSize(other.part, other.isRotated);
                    // otherì˜ ìœ—ë©´ì´ brickì˜ ë°”ë‹¥ê³¼ ë§ë‹¿ìŒ
                    const otherTop = other.y - otherSize.h;
                    const heightMatch = Math.abs(otherTop - brick.y) < 5;
                    // XZ ì˜ì—­ ê²¹ì¹¨
                    return heightMatch && hasXZOverlap(brick, other);
                });

                if (!supportFromBelow) {
                    // ìœ„ì—ì„œë§Œ ì—°ê²°ëœ ê²½ìš° - ìœ„ìª½ ë¸Œë¦­ì´ ì•ˆì •ì ì¸ì§€ í™•ì¸
                    const aboveBricks = bricks.filter(other => {
                        if (other.id === brick.id) return false;
                        // brickì˜ ìœ—ë©´ì´ otherì˜ ë°”ë‹¥ê³¼ ë§ë‹¿ìŒ
                        const brickTop = brick.y - brickSize.h;
                        const heightMatch = Math.abs(brickTop - other.y) < 5;
                        return heightMatch && hasXZOverlap(brick, other);
                    });

                    if (aboveBricks.length > 0) {
                        // ìœ„ìª½ ë¸Œë¦­ë“¤ì´ ì•„ë˜ì—ì„œ ì•ˆì •ì ìœ¼ë¡œ ì§€ì§€ë°›ëŠ”ì§€ í™•ì¸
                        // (ì§€ê·¸ì¬ê·¸/ë„“ì€ ì˜ì—­ êµ¬ì¡°ë©´ ì•ˆì •ì )
                        const aboveBricksHaveSupport = aboveBricks.some(ab => {
                            const abSize = getSize(ab.part, ab.isRotated);
                            // ìœ„ìª½ ë¸Œë¦­ì´ ì•„ë˜ì—ì„œ ì§€ì§€ë°›ëŠ” ë¸Œë¦­ì´ ìˆëŠ”ì§€
                            return bricks.some(support => {
                                if (support.id === ab.id || support.id === brick.id) return false;
                                const supportSize = getSize(support.part, support.isRotated);
                                const supportTop = support.y - supportSize.h;
                                const heightMatch = Math.abs(supportTop - ab.y) < 5;
                                return heightMatch && hasXZOverlap(ab, support);
                            });
                        });

                        // ìœ„ìª½ ë¸Œë¦­ì´ ì•ˆì •ì ì´ë©´ ì´ ë¸Œë¦­ë„ OK
                        if (aboveBricksHaveSupport) {
                            continue;  // WEAK ì²´í¬ ìŠ¤í‚µ
                        }

                        // ì´ ê²°í•© ê°•ë„
                        const totalStrength = aboveBricks.reduce((sum, ab) =>
                            sum + calcConnectionStrength(brick, ab), 0);

                        // ë§¤ë‹¬ë¦° ë¬´ê²Œ
                        const hangingWeight = calcHangingWeight(brick.id);

                        // ê²°í•©ë ¥ vs ë¬´ê²Œ ì²´í¬ (Luo ë…¼ë¬¸ ê¸°ë°˜)
                        // 1ìŠ¤í„°ë“œ ìµœëŒ€ ë§ˆì°° í•˜ì¤‘: 71.658g
                        // ì•ˆì „ ê³„ìˆ˜ 2ë°° ì ìš© (ì‹¤ì œ ì‚¬ìš© ì‹œ ì ˆë°˜ë§Œ í—ˆìš©)
                        const safeLoadPerStud = MAX_FRICTION_LOAD / 2;  // 35.8g per stud
                        const maxSupportableWeight = totalStrength * safeLoadPerStud;

                        if (hangingWeight > maxSupportableWeight) {
                            // ìœ„í—˜ë„ ê³„ì‚°: ë¬´ê²Œê°€ ì§€íƒ± ê°€ëŠ¥ëŸ‰ì˜ ëª‡ ë°°ì¸ì§€
                            const ratio = hangingWeight / maxSupportableWeight;
                            const severity = ratio > 2 ? 'high' : (ratio > 1.5 ? 'medium' : 'low');
                            issues.push({
                                brick_id: brick.id,
                                type: 'weak',
                                severity: severity,
                                message: `ë¸Œë¦­ #${brick.id} ìœ„ìª½ ê²°í•© ì•½í•¨ (${totalStrength}ìŠ¤í„°ë“œ ì§€íƒ± ${maxSupportableWeight.toFixed(1)}g < ì‹¤ì œ ${hangingWeight.toFixed(1)}g)`
                            });
                        }
                    }
                }
            }

            // ê³ ë¦½ëœ ë¸Œë¦­ ê²€ì‚¬ (ì•„ë¬´ ì—°ê²°ë„ ì—†ìŒ)
            for (const brick of bricks) {
                const connCount = connections.get(brick.id)?.size || 0;
                if (connCount === 0 && bricks.length > 1) {
                    // ì´ë¯¸ ë‹¤ë¥¸ ë¬¸ì œë¡œ ì¡í˜”ìœ¼ë©´ ìŠ¤í‚µ
                    if (issues.some(i => i.brick_id === brick.id)) continue;

                    issues.push({
                        brick_id: brick.id,
                        type: 'isolated',
                        severity: 'high',
                        message: `ë¸Œë¦­ #${brick.id} (${brick.part}) ë‹¤ë¥¸ ë¸Œë¦­ê³¼ ì—°ê²° ì—†ìŒ`
                    });
                }
            }

            if (bricks.length > 2) {
                const avgX = bricks.reduce((s, b) => s + b.x, 0) / bricks.length;
                const avgZ = bricks.reduce((s, b) => s + b.z, 0) / bricks.length;
                const baseBricks = bricks.filter(b => b.y >= -10);

                if (baseBricks.length > 0) {
                    const baseAvgX = baseBricks.reduce((s, b) => s + b.x, 0) / baseBricks.length;
                    const baseAvgZ = baseBricks.reduce((s, b) => s + b.z, 0) / baseBricks.length;
                    const offset = Math.sqrt((avgX - baseAvgX) ** 2 + (avgZ - baseAvgZ) ** 2);

                    if (offset > 50) {
                        // ì „ë³µ ë°©í–¥ ë²¡í„° ê³„ì‚° (ë² ì´ìŠ¤ ì¤‘ì‹¬ -> ë¬´ê²Œì¤‘ì‹¬)
                        const dx = avgX - baseAvgX;
                        const dz = avgZ - baseAvgZ;
                        const len = Math.sqrt(dx * dx + dz * dz);
                        const tippingX = len > 0 ? dx / len : 1;
                        const tippingZ = len > 0 ? dz / len : 0;

                        issues.push({
                            brick_id: null,
                            type: 'off_balance',
                            severity: 'critical',  // Changed to critical to trigger global tipping
                            message: `ë¬´ê²Œì¤‘ì‹¬ì´ ë² ì´ìŠ¤ì—ì„œ ${offset.toFixed(0)} LDU ë²—ì–´ë‚¨`,
                            data: {
                                tipping: { x: tippingX, z: tippingZ }
                            }
                        });
                    }
                }
            }

            // ì ìˆ˜ ê³„ì‚°: ë¬¸ì œ ë¸Œë¦­ ë¹„ìœ¨ ê¸°ë°˜
            // - unstable_base/off_balance â†’ 0ì 
            // - ê·¸ ì™¸: 100 - (ë¬¸ì œ ë¸Œë¦­ ìˆ˜ / ì „ì²´ ë¸Œë¦­ ìˆ˜ * 100)
            let score;
            const hasUnstableBase = issues.some(i =>
                i.type === 'unstable_base' || i.type === 'off_balance'
            );

            if (hasUnstableBase) {
                score = 0;
            } else {
                // top_onlyëŠ” ì ìˆ˜ì—ì„œ ì œì™¸
                const problemBrickIds = new Set(
                    issues
                        .filter(i => i.type !== 'top_only')
                        .map(i => i.brick_id)
                        .filter(id => id !== null)
                );
                const problemRatio = bricks.length > 0 ? problemBrickIds.size / bricks.length : 0;
                score = Math.round(100 * (1 - problemRatio));
            }
            score = Math.max(0, Math.min(100, score));

            return {
                totalBricks: bricks.length,
                issues,
                score,
                stable: !issues.some(i => i.type === 'unstable_base' || i.type === 'floating' || i.type === 'isolated')
            };
        }

        // ============================================
        // UI ì—…ë°ì´íŠ¸
        // ============================================
        // ì´ìŠˆ íƒ€ì…ë³„ ìƒ‰ìƒ (APIì—ì„œë„ ì œê³µí•˜ì§€ë§Œ í´ë°±ìš©)
        const ISSUE_TYPE_COLORS = {
            top_only: 0x0055FF,      // ğŸ”µ íŒŒë€ìƒ‰ - ìœ„ì—ì„œë§Œ ê²°í•©
            floating: 0xFF0000,      // ğŸ”´ ë¹¨ê°„ìƒ‰ - ê³µì¤‘ì— ë– ìˆìŒ
            isolated: 0xFFCC00,      // ğŸŸ¡ ë…¸ë€ìƒ‰ - ì—°ê²° ì—†ìŒ
            weak_connection: 0xFF8800,  // ğŸŸ  ì£¼í™©ìƒ‰ - ì•½í•œ ê²°í•©
            unstable_base: 0xFF00FF,    // ğŸŸ£ ë³´ë¼ìƒ‰ - ë¶ˆì•ˆì •í•œ ë² ì´ìŠ¤
            weak: 0xFF8800,          // ğŸŸ  ì£¼í™©ìƒ‰ (ë ˆê±°ì‹œ)
            off_balance: 0x9C27B0    // ë³´ë¼ìƒ‰
        };

        function highlightIssues(issues, brickColors = {}) {
            // APIì—ì„œ ë°›ì€ brick_colors ì‚¬ìš© (brick_id â†’ hex color)
            // brickColorsê°€ ìˆìœ¼ë©´ ê·¸ê±¸ ì‚¬ìš©, ì—†ìœ¼ë©´ issuesì—ì„œ ì§ì ‘ ì¶”ì¶œ

            // ë¬¸ì œ ë¸Œë¦­ ID ìˆ˜ì§‘
            const issueBrickIds = new Set(
                issues.map(i => i.brick_id).filter(id => id !== null)
            );

            // ëª¨ë“  ë¸Œë¦­ ìƒ‰ìƒ ì„¤ì •
            brickMeshes.forEach((mesh, id) => {
                if (issueBrickIds.has(id)) {
                    let color;

                    // 1. APIì—ì„œ ë°›ì€ brick_colors ì‚¬ìš© (ìš°ì„ )
                    if (brickColors[id]) {
                        color = parseInt(brickColors[id].replace('#', ''), 16);
                    }
                    // 2. issuesì—ì„œ color í•„ë“œ ì‚¬ìš©
                    else {
                        const issue = issues.find(i => i.brick_id === id);
                        if (issue && issue.color) {
                            color = parseInt(issue.color.replace('#', ''), 16);
                        } else if (issue) {
                            // 3. í´ë°±: ì´ìŠˆ íƒ€ì…ìœ¼ë¡œ ìƒ‰ìƒ ê²°ì •
                            color = ISSUE_TYPE_COLORS[issue.type] || 0xFF0000;
                        } else {
                            color = 0xFF0000;
                        }
                    }

                    mesh.material = new THREE.MeshStandardMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.4,
                        roughness: 0.5,
                        metalness: 0.1
                    });
                } else {
                    // ì •ìƒ ë¸Œë¦­ â†’ ì´ˆë¡ìƒ‰
                    mesh.material = new THREE.MeshStandardMaterial({
                        color: 0x4caf50,
                        emissive: 0x4caf50,
                        emissiveIntensity: 0.2,
                        roughness: 0.5,
                        metalness: 0.1
                    });
                }
            });
        }

        function updateUI(result) {
            document.getElementById('resultPanel').classList.remove('hidden');

            const scoreBox = document.getElementById('scoreBox');
            const scoreValue = document.getElementById('scoreValue');
            scoreValue.textContent = result.score;
            scoreBox.className = 'score ' + (result.stable ? 'stable' : 'unstable');

            document.getElementById('totalBricks').textContent = result.totalBricks;
            document.getElementById('issueCount').textContent = result.issues.length;
            document.getElementById('stability').textContent = result.stable ? 'âœ… ì•ˆì •' : 'âš ï¸ ë¶ˆì•ˆì •';

            // Rust ë°±ì—”ë“œ ì •ë³´ í‘œì‹œ
            const backendInfo = document.getElementById('backendInfo');
            if (backendInfo) {
                if (result.backend === 'rust') {
                    backendInfo.innerHTML = `ğŸ¦€ <span style="color: #ff6b6b;">RUST</span> (${result.elapsed_ms?.toFixed(2) || '?'}ms)`;
                } else {
                    backendInfo.innerHTML = `ğŸ <span style="color: #ffc107;">Python</span>`;
                }
            }

            const issueList = document.getElementById('issueList');
            issueList.innerHTML = '';

            if (result.issues.length === 0) {
                issueList.innerHTML = '<p style="color: #4caf50; text-align: center; padding: 20px;">âœ… ë¬¸ì œ ì—†ìŒ!</p>';
            } else {
                for (const issue of result.issues) {
                    const item = document.createElement('div');
                    item.className = `issue-item ${issue.severity}`;
                    item.innerHTML = `
                        <div class="issue-type">${issue.type} (${issue.severity})</div>
                        <div class="issue-msg">${issue.message}</div>
                    `;
                    item.onclick = () => focusOnBrick(issue.brick_id);
                    issueList.appendChild(item);
                }
            }
        }

        let blinkInterval = null;
        let blinkState = null;  // ê¹œë¹¡ì„ ìƒíƒœ ì €ì¥

        function focusOnBrick(brickId) {
            if (brickId === null || !model) return;

            const mesh = brickMeshes.get(brickId);
            if (mesh) {
                // ì¹´ë©”ë¼ ì´ë™
                const worldPos = new THREE.Vector3();
                mesh.getWorldPosition(worldPos);
                controls.target.copy(worldPos);
                controls.update();

                // ì´ì „ ê¹œë¹¡ì„ ì¤‘ì§€ & ë³µì›
                if (blinkInterval) {
                    clearInterval(blinkInterval);
                    restoreAllMaterials();
                }

                // ëª¨ë“  ë¸Œë¦­ì˜ ì›ë³¸ material ì €ì¥
                const originalMaterials = new Map();
                brickMeshes.forEach((m, id) => {
                    originalMaterials.set(id, m.material);
                });

                // ë‹¤ë¥¸ ë¸Œë¦­ë“¤ ë°˜íˆ¬ëª…ìœ¼ë¡œ (ëŒ€ìƒ ë¸Œë¦­ ì œì™¸)
                const ghostMaterial = new THREE.MeshStandardMaterial({
                    color: 0x888888,
                    transparent: true,
                    opacity: 0.15,
                    depthWrite: false
                });

                brickMeshes.forEach((m, id) => {
                    if (id !== brickId) {
                        m.material = ghostMaterial;
                    }
                });

                // ëŒ€ìƒ ë¸Œë¦­ ê¹œë¹¡ì„ìš© material
                const originalMaterial = mesh.material;
                const highlightMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.9
                });

                blinkState = { originalMaterials, targetId: brickId };

                // ê¹œë¹¡ì„ íš¨ê³¼ (5ë²ˆ)
                let count = 0;
                let isHighlight = false;
                blinkInterval = setInterval(() => {
                    isHighlight = !isHighlight;
                    mesh.material = isHighlight ? highlightMaterial : originalMaterial;
                    count++;
                    if (count >= 10) {  // 5ë²ˆ ê¹œë¹¡ì„
                        clearInterval(blinkInterval);
                        blinkInterval = null;
                        restoreAllMaterials();
                    }
                }, 200);
            }
        }

        function restoreAllMaterials() {
            if (blinkState && blinkState.originalMaterials) {
                blinkState.originalMaterials.forEach((mat, id) => {
                    const m = brickMeshes.get(id);
                    if (m) m.material = mat;
                });
                blinkState = null;
            }
        }

        // ============================================
        // ìë™ íˆ¬ì–´ ì‹œìŠ¤í…œ
        // ============================================
        let tourQueue = [];
        let tourRunning = false;
        let tourIndex = 0;

        function startTour() {
            if (!lastAnalysisResult || lastAnalysisResult.issues.length === 0) {
                alert('ë¶„ì„í•  ì´ìŠˆê°€ ì—†ìŠµë‹ˆë‹¤');
                return;
            }
            if (tourRunning) return;

            // ì´ìŠˆ í ìƒì„± (brick_idê°€ ìˆëŠ” ê²ƒë§Œ)
            tourQueue = lastAnalysisResult.issues
                .filter(i => i.brick_id !== null)
                .map(i => ({ brickId: i.brick_id, message: i.message, type: i.type }));

            if (tourQueue.length === 0) {
                alert('í•˜ì´ë¼ì´íŠ¸í•  ë¸Œë¦­ì´ ì—†ìŠµë‹ˆë‹¤');
                return;
            }

            tourRunning = true;
            tourIndex = 0;

            // UI ì—…ë°ì´íŠ¸
            document.getElementById('tourBtn').style.display = 'none';
            document.getElementById('stopTourBtn').style.display = 'block';
            document.getElementById('tourProgress').style.display = 'block';
            document.getElementById('tourTotal').textContent = tourQueue.length;

            // ì²« ë²ˆì§¸ ì‹œì‘
            showNextInTour();
        }

        function stopTour() {
            tourRunning = false;
            tourQueue = [];
            tourIndex = 0;

            // ì§„í–‰ ì¤‘ì¸ ê¹œë¹¡ì„ ì¤‘ì§€
            if (blinkInterval) {
                clearInterval(blinkInterval);
                blinkInterval = null;
            }
            restoreAllMaterials();

            // UI ë³µì›
            document.getElementById('tourBtn').style.display = 'block';
            document.getElementById('stopTourBtn').style.display = 'none';
            document.getElementById('tourProgress').style.display = 'none';
        }

        function showNextInTour() {
            if (!tourRunning || tourIndex >= tourQueue.length) {
                // íˆ¬ì–´ ì™„ë£Œ
                stopTour();
                return;
            }

            const item = tourQueue[tourIndex];
            document.getElementById('tourCurrent').textContent = tourIndex + 1;

            // í•´ë‹¹ ì´ìŠˆ ì•„ì´í…œ í•˜ì´ë¼ì´íŠ¸
            const issueItems = document.querySelectorAll('.issue-item');
            issueItems.forEach((el, idx) => {
                el.style.outline = idx === tourIndex ? '2px solid #e94560' : 'none';
            });

            // ê¹œë¹¡ì„ ì‹œì‘ (ì½œë°±ìœ¼ë¡œ ë‹¤ìŒ ì§„í–‰)
            focusOnBrickWithCallback(item.brickId, () => {
                tourIndex++;
                // ì ì‹œ ëŒ€ê¸° í›„ ë‹¤ìŒ
                setTimeout(() => {
                    showNextInTour();
                }, 500);
            });
        }

        function focusOnBrickWithCallback(brickId, onComplete) {
            if (brickId === null || !model) {
                if (onComplete) onComplete();
                return;
            }

            const mesh = brickMeshes.get(brickId);
            if (!mesh) {
                if (onComplete) onComplete();
                return;
            }

            // ì¹´ë©”ë¼ ì´ë™
            const worldPos = new THREE.Vector3();
            mesh.getWorldPosition(worldPos);
            controls.target.copy(worldPos);
            controls.update();

            // ì´ì „ ê¹œë¹¡ì„ ì¤‘ì§€ & ë³µì›
            if (blinkInterval) {
                clearInterval(blinkInterval);
                restoreAllMaterials();
            }

            // ëª¨ë“  ë¸Œë¦­ì˜ ì›ë³¸ material ì €ì¥
            const originalMaterials = new Map();
            brickMeshes.forEach((m, id) => {
                originalMaterials.set(id, m.material);
            });

            // ë‹¤ë¥¸ ë¸Œë¦­ë“¤ ë°˜íˆ¬ëª…ìœ¼ë¡œ
            const ghostMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                transparent: true,
                opacity: 0.15,
                depthWrite: false
            });

            brickMeshes.forEach((m, id) => {
                if (id !== brickId) {
                    m.material = ghostMaterial;
                }
            });

            // ëŒ€ìƒ ë¸Œë¦­ ê¹œë¹¡ì„
            const originalMaterial = mesh.material;
            const highlightMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.9
            });

            blinkState = { originalMaterials, targetId: brickId };

            let count = 0;
            let isHighlight = false;
            blinkInterval = setInterval(() => {
                isHighlight = !isHighlight;
                mesh.material = isHighlight ? highlightMaterial : originalMaterial;
                count++;
                if (count >= 6) {  // 3ë²ˆ ê¹œë¹¡ì„ (íˆ¬ì–´ëŠ” ì§§ê²Œ)
                    clearInterval(blinkInterval);
                    blinkInterval = null;
                    restoreAllMaterials();
                    if (onComplete) onComplete();
                }
            }, 180);
        }

        // ============================================
        // ì „ì²´ ë¶ˆëŸ‰ ë¸Œë¦­ ê¹œë¹¡ì„
        // ============================================
        let blinkAllInterval = null;

        function blinkAllBadBricks() {
            if (!lastAnalysisResult || lastAnalysisResult.issues.length === 0) {
                alert('ë¶„ì„í•  ì´ìŠˆê°€ ì—†ìŠµë‹ˆë‹¤');
                return;
            }

            // ì§„í–‰ ì¤‘ì¸ ê¹œë¹¡ì„ ì¤‘ì§€
            if (blinkInterval) {
                clearInterval(blinkInterval);
                blinkInterval = null;
            }
            if (blinkAllInterval) {
                clearInterval(blinkAllInterval);
                blinkAllInterval = null;
            }
            stopTour();
            restoreAllMaterials();

            // ë¶ˆëŸ‰ ë¸Œë¦­ ID ìˆ˜ì§‘ (top_onlyëŠ” ì œì™¸ - ì¡°ë¦½ ìˆœì„œ ë¬¸ì œì¼ ë¿ ì‹¬ê°í•œ ë¶ˆëŸ‰ ì•„ë‹˜)
            const badBrickIds = new Set(
                lastAnalysisResult.issues
                    .filter(i => i.type !== 'top_only')  // top_only ì œì™¸
                    .map(i => i.brick_id)
                    .filter(id => id !== null)
            );

            if (badBrickIds.size === 0) {
                alert('ë¶ˆëŸ‰ ë¸Œë¦­ì´ ì—†ìŠµë‹ˆë‹¤!');
                return;
            }

            // ì›ë³¸ material ì €ì¥
            const originalMaterials = new Map();
            brickMeshes.forEach((m, id) => {
                originalMaterials.set(id, m.material);
            });

            // ë¶ˆëŸ‰ ë¸Œë¦­ í•˜ì´ë¼ì´íŠ¸ material (ë³´ì¼ ë•Œ)
            const badVisibleMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.6,
                transparent: false,
                opacity: 1.0
            });

            // ë¶ˆëŸ‰ ë¸Œë¦­ íˆ¬ëª… material (ì•ˆ ë³´ì¼ ë•Œ)
            const badInvisibleMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.0,
                depthWrite: false
            });

            // ì •ìƒ ë¸Œë¦­ ë°˜íˆ¬ëª…
            const goodGhostMaterial = new THREE.MeshStandardMaterial({
                color: 0x4caf50,
                emissive: 0x4caf50,
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.7,
                depthWrite: true
            });

            // ì´ˆê¸° ìƒíƒœ: ì •ìƒì€ ë°˜íˆ¬ëª…, ë¶ˆëŸ‰ì€ íˆ¬ëª…
            brickMeshes.forEach((m, id) => {
                if (badBrickIds.has(id)) {
                    m.material = badInvisibleMaterial;
                } else {
                    m.material = goodGhostMaterial;
                }
            });

            blinkState = { originalMaterials, targetId: null };

            // ê¹œë¹¡ì„ (ì „ì²´ ë¶ˆëŸ‰ ë™ì‹œ: íˆ¬ëª… â†” ë¹¨ê°•)
            let count = 0;
            let isVisible = false;
            blinkAllInterval = setInterval(() => {
                isVisible = !isVisible;
                badBrickIds.forEach(id => {
                    const mesh = brickMeshes.get(id);
                    if (mesh) {
                        mesh.material = isVisible ? badVisibleMaterial : badInvisibleMaterial;
                    }
                });
                count++;
                if (count >= 10) {  // 5ë²ˆ ê¹œë¹¡ì„
                    clearInterval(blinkAllInterval);
                    blinkAllInterval = null;
                    restoreAllMaterials();
                }
            }, 300);
        }

        function showLoading(show) {
            document.getElementById('loading').classList.toggle('hidden', !show);
        }

        // ============================================
        // ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜
        // ============================================
        // ============================================
        // ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜
        // ============================================
        let physicsRunning = false;
        let fallingBricks = [];
        let globalTipping = null; // ì „ì²´ ì „ë³µ ìƒíƒœ
        let originalPositions = new Map();
        let lastAnalysisResult = null;

        // ë¬´ê²Œì¤‘ì‹¬ ì‹œë®¬ë ˆì´ì…˜ (ì „ì²´ ëª¨ë¸ ì „ë³µ)
        function startCOMSimulation() {
            if (!model || !lastAnalysisResult) {
                alert('ë¨¼ì € ë¶„ì„ì„ ì‹¤í–‰í•˜ì„¸ìš”');
                return;
            }
            if (physicsRunning) return;

            physicsRunning = true;
            fallingBricks = [];
            globalTipping = null;

            // ì›ë˜ ìœ„ì¹˜ ì €ì¥
            brickMeshes.forEach((mesh, id) => {
                originalPositions.set(id, mesh.position.clone());
            });

            // ì „ì—­ ë¶ˆì•ˆì •(ì „ë³µ) ì²´í¬
            const globalIssue = lastAnalysisResult.issues.find(i =>
                i.type === 'unstable_base' || i.type === 'off_balance' ||
                (i.severity === 'critical' && i.brick_id === null)
            );

            if (globalIssue) {
                console.log("âš ï¸ ë¬´ê²Œì¤‘ì‹¬ ì‹œë®¬ë ˆì´ì…˜: ì „ë³µ ì‹œì‘");
                console.log("globalIssue:", JSON.stringify(globalIssue, null, 2));

                let axis = new THREE.Vector3(1, 0, 0);
                let dir = 1;

                if (globalIssue.data && globalIssue.data.tipping) {
                    const tx = globalIssue.data.tipping.x;
                    const tz = globalIssue.data.tipping.z;
                    console.log(`Tipping Vector: x=${tx}, z=${tz}`);
                    axis.set(-tz, 0, tx).normalize();
                    dir = 1;
                } else {
                    console.log("ì „ë³µ ë°ì´í„° ì—†ìŒ - ëœë¤ ë°©í–¥(JS í´ë°±)");
                    axis.set(Math.random() > 0.5 ? 1 : 0, 0, Math.random() > 0.5 ? 1 : 0).normalize();
                    if (axis.length() === 0) axis.set(1, 0, 0);
                    dir = Math.random() > 0.5 ? 1 : -1;
                }

                globalTipping = {
                    axis: axis,
                    dir: dir,
                    velocity: 0,
                    angle: 0
                };

                animatePhysics();
            } else {
                alert('ë¬´ê²Œì¤‘ì‹¬ì´ ì•ˆì •ì ì…ë‹ˆë‹¤! (ì „ë³µ ìœ„í—˜ ì—†ìŒ)');
                physicsRunning = false;
            }
        }

        // ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ (ê°œë³„ ë¸Œë¦­ ë¶•ê´´)
        function startCrumbleSimulation() {
            if (!model || !lastAnalysisResult) {
                alert('ë¨¼ì € ë¶„ì„ì„ ì‹¤í–‰í•˜ì„¸ìš”');
                return;
            }
            if (physicsRunning) return;

            physicsRunning = true;
            fallingBricks = [];
            globalTipping = null;

            // ì›ë˜ ìœ„ì¹˜ ì €ì¥
            brickMeshes.forEach((mesh, id) => {
                originalPositions.set(id, mesh.position.clone());
            });

            // ë¬¸ì œ ë¸Œë¦­ë§Œ ìˆ˜ì§‘ (floating, weak, isolated)
            const problemBrickIds = new Set(
                lastAnalysisResult.issues
                    .filter(i => i.type === 'floating' || i.type === 'weak' || i.type === 'isolated')
                    .map(i => i.brick_id)
                    .filter(id => id !== null)
            );

            problemBrickIds.forEach(id => {
                const mesh = brickMeshes.get(id);
                if (mesh) {
                    fallingBricks.push({
                        mesh,
                        velocity: 0,
                        rotation: (Math.random() - 0.5) * 0.1,
                        rotationAxis: Math.random() > 0.5 ? 'x' : 'z'
                    });
                }
            });

            if (fallingBricks.length === 0) {
                alert('ë–¨ì–´ì§ˆ ë¸Œë¦­ì´ ì—†ìŠµë‹ˆë‹¤! (ëª¨ë“  ë¸Œë¦­ì´ ì•ˆì •ì )');
                physicsRunning = false;
                return;
            }

            console.log(`ğŸ’¥ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜: ${fallingBricks.length}ê°œ ë¸Œë¦­ ë¶•ê´´`);
            animatePhysics();
        }

        // ê¸°ì¡´ í˜¸í™˜ì„ ìœ„í•œ ë˜í¼ (ë ˆê±°ì‹œ)
        function startPhysicsSimulation() {
            startCrumbleSimulation();
        }

        function animatePhysics() {
            if (!physicsRunning) return;

            // 1. ì „ì²´ ì „ë³µ (Tipping)
            if (globalTipping) {
                const gravity = 0.002; // ê°ê°€ì†ë„
                globalTipping.velocity += gravity;
                globalTipping.angle += globalTipping.velocity;

                // ì›”ë“œ ì¶• ê¸°ì¤€ìœ¼ë¡œ íšŒì „
                model.rotateOnWorldAxis(globalTipping.axis, globalTipping.velocity * globalTipping.dir);

                // 90ë„(PI/2) ì´ìƒ ë„˜ì–´ê°€ë©´ ë©ˆì¶¤
                if (globalTipping.angle > Math.PI / 2) {
                    physicsRunning = false;
                    // ì•½ê°„ì˜ ë°”ìš´ìŠ¤ íš¨ê³¼ë¥¼ ì¤„ ìˆ˜ë„ ìˆìŒ
                } else {
                    requestAnimationFrame(animatePhysics);
                }
                return;
            }

            // 2. ë‚±ì•Œ ë¶•ê´´ (Crumbling)
            const gravity = 2;
            const groundY = 300; // ëŒ€ëµì ì¸ ë°”ë‹¥
            const bounce = 0.3;
            let allStopped = true;

            for (const brick of fallingBricks) {
                brick.velocity += gravity;
                brick.mesh.position.y += brick.velocity;

                if (brick.mesh.position.y < groundY) {
                    if (brick.rotationAxis === 'x') {
                        brick.mesh.rotation.x += brick.rotation;
                    } else {
                        brick.mesh.rotation.z += brick.rotation;
                    }
                }

                if (brick.mesh.position.y > groundY) {
                    brick.mesh.position.y = groundY;
                    brick.velocity = -brick.velocity * bounce;
                    if (Math.abs(brick.velocity) < 1) {
                        brick.velocity = 0;
                    }
                }

                if (Math.abs(brick.velocity) > 0.1 || brick.mesh.position.y < groundY - 1) {
                    allStopped = false;
                }
            }

            if (!allStopped) {
                requestAnimationFrame(animatePhysics);
            } else {
                physicsRunning = false;
            }
        }

        function resetSimulation() {
            physicsRunning = false;
            fallingBricks = [];
            globalTipping = null;

            // ì›ë˜ ìœ„ì¹˜ ë³µì›
            originalPositions.forEach((pos, id) => {
                const mesh = brickMeshes.get(id);
                if (mesh) {
                    mesh.position.copy(pos);
                    mesh.rotation.set(Math.PI, 0, 0); // ê°œë³„ ë¸Œë¦­ íšŒì „ ì´ˆê¸°í™”? (LDraw ê¸°ë³¸ì´ meshë³„ë¡œ ë‹¤ë¥¼ ìˆ˜ ìˆì–´ì„œ ì£¼ì˜)
                    // loadLDRì—ì„œ child.userData.originalMaterial ì €ì¥í–ˆë“¯ì´ originalRotationë„ ì €ì¥í–ˆì–´ì•¼ ì™„ë²½í•˜ì§€ë§Œ
                    // ì—¬ê¸°ì„  LDrawLoaderê°€ ê°œë³„ mesh íšŒì „ì„ ì£¼ì§€ ì•Šê³  vertexì— êµ½ëŠ” ë°©ì‹ì¸ì§€ í™•ì¸ í•„ìš”.
                    // ë³´í†µ LDrawLoaderëŠ” mesh ìì²´ rotationì€ 0 ì´ê³  geometryê°€ ë³€í™˜ë˜ì–´ ìˆìŒ.
                    // ë‹¨, 3004.dat ë“±ì„ ì¸ìŠ¤í„´ì‹±í• ë• ë‹¤ë¦„.
                    // ì¼ë‹¨ (Math.PI, 0, 0)ì€ model(ê·¸ë£¹)ì˜ íšŒì „ê°’ì„. ê°œë³„ meshëŠ” (0,0,0)ì´ë‚˜ (PI,0,0)ì¼ ìˆ˜ ìˆìŒ.
                    // ê°„ë‹¨íˆ mesh.rotation.set(0,0,0) ë˜ëŠ” ì´ˆê¸°ê°’ ì‚¬ìš©ì´ ë§ìŒ.
                    // í•˜ì§€ë§Œ fallingBricks ë¡œì§ì—ì„œ mesh.rotationì„ ê±´ë“œë ¸ìœ¼ë¯€ë¡œ ë³µêµ¬ í•„ìš”.

                    // ë³µêµ¬: ê·¸ëƒ¥ 0,0,0ìœ¼ë¡œ (ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ë§ìŒ)
                    mesh.rotation.set(0, 0, 0);
                }
            });

            // ëª¨ë¸ ì „ì²´ íšŒì „ ë¦¬ì…‹
            if (model) {
                model.rotation.set(Math.PI, 0, 0);
            }
        }

        // ============================================
        // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
        // ============================================

        // Rust ë°±ì—”ë“œ API í˜¸ì¶œ (ê°€ì† ë¬¼ë¦¬ ì—”ì§„)
        async function analyzeWithRust(ldrContent) {
            const response = await fetch('/api/test/all', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ldr_content: ldrContent })
            });
            const data = await response.json();

            // ì„œë²„ ì‘ë‹µì„ í´ë¼ì´ì–¸íŠ¸ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
            const issues = data.issues.map(i => ({
                brick_id: i.brick_id,
                type: i.type,
                severity: i.severity,
                message: i.message,
                color: i.color,  // ì´ìŠˆ íƒ€ì…ë³„ ìƒ‰ìƒ (hex)
                data: i.data     // ì¶”ê°€ ë°ì´í„° (ì „ë³µ ë²¡í„° ë“±)
            }));

            // ì„œë²„ì—ì„œ ê³„ì‚°ëœ ì ìˆ˜ ì‚¬ìš© (ìƒˆ ë¡œì§: ë¬¸ì œ ë¸Œë¦­ ë¹„ìœ¨ ê¸°ë°˜)
            const score = data.score;
            const hasUnstableBase = issues.some(i =>
                i.type === 'unstable_base' || i.type === 'off_balance'
            );

            return {
                totalBricks: data.brick_count,
                issues: issues,
                score: score,
                stable: data.stable,  // ì„œë²„ì—ì„œ ê³„ì‚°ëœ ì•ˆì •ì„± ì‚¬ìš©
                backend: data.backend,
                elapsed_ms: data.elapsed_ms,
                brick_colors: data.brick_colors || {},  // brick_id â†’ hex color
                issue_colors: data.issue_colors || {}   // ì´ìŠˆ íƒ€ì…ë³„ ìƒ‰ìƒ ë²”ë¡€
            };
        }

        async function analyze(ldrContent) {
            try {
                await loadLDR(ldrContent);

                // ğŸš€ Rust ë°±ì—”ë“œ API ì‚¬ìš© (ê°€ì†!)
                let result;
                try {
                    result = await analyzeWithRust(ldrContent);
                    console.log(`ğŸ¦€ Rust ë°±ì—”ë“œ ì‚¬ìš©: ${result.elapsed_ms?.toFixed(3)}ms`);
                } catch (apiError) {
                    console.warn('Rust API ì‹¤íŒ¨, JS í´ë°±:', apiError);
                    result = judgeBricks(ldrContent);  // í´ë°±
                }

                lastAnalysisResult = result;  // ê²°ê³¼ ì €ì¥
                highlightIssues(result.issues, result.brick_colors || {});
                updateUI(result);
            } catch (error) {
                console.error('ë¶„ì„ ì‹¤íŒ¨:', error);
                alert('LDR ë¶„ì„ ì‹¤íŒ¨: ' + error.message);
                showLoading(false);
            }
        }

        document.getElementById('ldrFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const content = await file.text();
            document.getElementById('ldrText').value = content;
            await analyze(content);
        });

        document.getElementById('analyzeBtn').addEventListener('click', async () => {
            const content = document.getElementById('ldrText').value.trim();
            if (!content) {
                alert('LDR ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”');
                return;
            }
            await analyze(content);
        });

        // ë“œë˜ê·¸ ì•¤ ë“œë¡­
        const uploadArea = document.querySelector('.upload-area');
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = '#e94560';
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.style.borderColor = '#0f4c75';
        });
        uploadArea.addEventListener('drop', async (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = '#0f4c75';
            const file = e.dataTransfer.files[0];
            if (file) {
                // LDR íŒŒì¼ë§Œ í—ˆìš©
                const ext = file.name.split('.').pop().toLowerCase();
                if (!['ldr', 'mpd', 'dat'].includes(ext)) {
                    alert('LDR íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤ (.ldr, .mpd, .dat)');
                    return;
                }
                const content = await file.text();
                document.getElementById('ldrText').value = content;
                await analyze(content);
            }
        });

        // ìë™ íˆ¬ì–´ ë²„íŠ¼
        document.getElementById('tourBtn').addEventListener('click', () => {
            startTour();
        });

        document.getElementById('stopTourBtn').addEventListener('click', () => {
            stopTour();
        });

        // ì „ì²´ ë¶ˆëŸ‰ ê¹œë¹¡ì„ ë²„íŠ¼
        document.getElementById('blinkAllBtn').addEventListener('click', () => {
            blinkAllBadBricks();
        });

        // ë¬´ê²Œì¤‘ì‹¬ ì‹œë®¬ë ˆì´ì…˜ ë²„íŠ¼
        document.getElementById('comSimBtn').addEventListener('click', () => {
            startCOMSimulation();
        });

        // ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ë²„íŠ¼ (ë¶•ê´´)
        document.getElementById('physicsBtn').addEventListener('click', () => {
            startCrumbleSimulation();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            resetSimulation();
            stopTour();  // íˆ¬ì–´ë„ ì¤‘ì§€
            // ë‹¤ì‹œ ë¶„ì„
            const content = document.getElementById('ldrText').value.trim();
            if (content) {
                analyze(content);
            }
        });

        // ============================================
        // ë¶ˆì•ˆì • ë¸Œë¦­ ë³‘í•© ê¸°ëŠ¥
        // ============================================

        // ë¸Œë¦­ íŒŒì‹± ìœ í‹¸ë¦¬í‹°
        function parseLdrBricks(ldrContent) {
            const lines = ldrContent.split('\n');
            const bricks = [];
            let brickId = 0;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line || !line.startsWith('1 ')) continue;

                const parts = line.split(/\s+/);
                if (parts.length >= 15) {
                    const color = parseInt(parts[1]);
                    const x = parseFloat(parts[2]);
                    const y = parseFloat(parts[3]);
                    const z = parseFloat(parts[4]);
                    // íšŒì „ í–‰ë ¬
                    const rotA = parseFloat(parts[5]);
                    const rotC = parseFloat(parts[7]);
                    const isRotated = Math.abs(rotA) < 0.5 && Math.abs(rotC) > 0.5;
                    const part = parts[14];

                    bricks.push({
                        id: brickId,
                        lineIndex: i,
                        color, x, y, z, part, isRotated,
                        originalLine: lines[i]
                    });
                    brickId++;
                }
            }
            return { bricks, lines };
        }

        // ë¸Œë¦­ í¬ê¸° ì •ë³´ (LDU ë‹¨ìœ„)
        const MERGE_PART_SIZE = {
            '3005.dat': { w: 20, d: 20, studsW: 1, studsD: 1 },  // 1x1
            '3004.dat': { w: 40, d: 20, studsW: 2, studsD: 1 },  // 1x2
            '3622.dat': { w: 60, d: 20, studsW: 3, studsD: 1 },  // 1x3
            '3010.dat': { w: 80, d: 20, studsW: 4, studsD: 1 },  // 1x4
            '3009.dat': { w: 120, d: 20, studsW: 6, studsD: 1 }, // 1x6
            '3008.dat': { w: 160, d: 20, studsW: 8, studsD: 1 }, // 1x8
            '3003.dat': { w: 40, d: 40, studsW: 2, studsD: 2 },  // 2x2
            '3002.dat': { w: 60, d: 40, studsW: 3, studsD: 2 },  // 2x3
            '3001.dat': { w: 80, d: 40, studsW: 4, studsD: 2 },  // 2x4
            '3006.dat': { w: 120, d: 40, studsW: 6, studsD: 2 }, // 2x6
            '3007.dat': { w: 160, d: 40, studsW: 8, studsD: 2 }, // 2x8
        };

        // ìŠ¤í„°ë“œ í¬ê¸°ë¡œ íŒŒíŠ¸ ì´ë¦„ ì°¾ê¸°
        const STUDS_TO_PART = {
            // ê¸°ë³¸ ë°©í–¥ (DxW)
            '1x1': '3005.dat', '1x2': '3004.dat', '1x3': '3622.dat', '1x4': '3010.dat',
            '1x6': '3009.dat', '1x8': '3008.dat',
            '2x2': '3003.dat', '2x3': '3002.dat', '2x4': '3001.dat',
            '2x6': '3006.dat', '2x8': '3007.dat',
            // íšŒì „ ë°©í–¥ (ê°™ì€ íŒŒíŠ¸, ë‹¤ë¥¸ í‚¤)
            '2x1': '3004.dat',  // 1x2ì™€ ë™ì¼
            '3x1': '3622.dat',  // 1x3ê³¼ ë™ì¼
            '4x1': '3010.dat',  // 1x4ì™€ ë™ì¼
            '6x1': '3009.dat',  // 1x6ê³¼ ë™ì¼
            '8x1': '3008.dat',  // 1x8ê³¼ ë™ì¼
            '3x2': '3002.dat',  // 2x3ê³¼ ë™ì¼
            '4x2': '3001.dat',  // 2x4ì™€ ë™ì¼
            '6x2': '3006.dat',  // 2x6ê³¼ ë™ì¼
            '8x2': '3007.dat',  // 2x8ê³¼ ë™ì¼
        };

        function getPartSize(part, isRotated) {
            const size = MERGE_PART_SIZE[part] || { w: 20, d: 20, studsW: 1, studsD: 1 };
            if (isRotated) {
                return { w: size.d, d: size.w, studsW: size.studsD, studsD: size.studsW };
            }
            return size;
        }

        // ì¸ì ‘ ë¸Œë¦­ ì°¾ê¸° (ê°™ì€ Y, X ë˜ëŠ” Zì¶•ìœ¼ë¡œ ë¶™ì–´ìˆìŒ)
        // floatingIds: ë¶ˆì•ˆì •í•œ ë¸Œë¦­ ID - ì´ëŸ° ë¸Œë¦­ê³¼ëŠ” ë³‘í•©í•˜ì§€ ì•ŠìŒ!
        // preferredAxis: 'x', 'z', ë˜ëŠ” null (ë‘˜ ë‹¤ ê°€ëŠ¥)
        function findAdjacentBrick(targetBrick, bricks, excludeIds, floatingIds, preferredAxis = null) {
            const targetSize = getPartSize(targetBrick.part, targetBrick.isRotated);

            for (const other of bricks) {
                if (other.id === targetBrick.id) continue;
                if (excludeIds.has(other.id)) continue;

                // í•µì‹¬: ì¸ì ‘ ë¸Œë¦­ì´ ë¶ˆì•ˆì •í•˜ë©´(floatingì´ë©´) ìŠ¤í‚µ!
                if (floatingIds && floatingIds.has(other.id)) continue;

                const otherSize = getPartSize(other.part, other.isRotated);

                // ê°™ì€ Y (ê°™ì€ ì¸µ)
                if (Math.abs(other.y - targetBrick.y) > 1) continue;

                // Xì¶•ìœ¼ë¡œ ì¸ì ‘ ì²´í¬: Z ì¤‘ì‹¬ì´ ì •ë ¬ë˜ì–´ ìˆì–´ì•¼ í•¨
                const zDiff = Math.abs(other.z - targetBrick.z);
                const minHalfD = Math.min(targetSize.d, otherSize.d) / 2;
                const zAligned = zDiff <= minHalfD + 1;

                // Zì¶•ìœ¼ë¡œ ì¸ì ‘ ì²´í¬: X ì¤‘ì‹¬ì´ ì •ë ¬ë˜ì–´ ìˆì–´ì•¼ í•¨
                const xDiff = Math.abs(other.x - targetBrick.x);
                const minHalfW = Math.min(targetSize.w, otherSize.w) / 2;
                const xAligned = xDiff <= minHalfW + 1;

                // Xì¶•ìœ¼ë¡œ ì¸ì ‘ (Z ì¤‘ì‹¬ì´ ì •ë ¬) - preferredAxisê°€ nullì´ê±°ë‚˜ 'x'ì¼ ë•Œë§Œ
                if ((!preferredAxis || preferredAxis === 'x') && zAligned) {
                    const gap = xDiff;
                    const expectedGap = (targetSize.w + otherSize.w) / 2;
                    if (Math.abs(gap - expectedGap) < 5) {
                        return { brick: other, axis: 'x' };
                    }
                }

                // Zì¶•ìœ¼ë¡œ ì¸ì ‘ (X ì¤‘ì‹¬ì´ ì •ë ¬) - preferredAxisê°€ nullì´ê±°ë‚˜ 'z'ì¼ ë•Œë§Œ
                if ((!preferredAxis || preferredAxis === 'z') && xAligned) {
                    const gap = zDiff;
                    const expectedGap = (targetSize.d + otherSize.d) / 2;
                    if (Math.abs(gap - expectedGap) < 5) {
                        return { brick: other, axis: 'z' };
                    }
                }
            }
            return null;
        }

        // ë‘ ë¸Œë¦­ ë³‘í•© (floatingBrick, stableBrick, axis, ì¶©ëŒ ê²€ì‚¬ìš© bricks ë°°ì—´)
        // stable ë¸Œë¦­ ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í™•ì¥
        function mergeTwoBricks(floatingBrick, stableBrick, axis, allBricks, linesToRemove) {
            const floatSize = getPartSize(floatingBrick.part, floatingBrick.isRotated);
            const stableSize = getPartSize(stableBrick.part, stableBrick.isRotated);

            // ìƒˆ ë¸Œë¦­ í¬ê¸° ê³„ì‚°
            let newStudsW, newStudsD;
            if (axis === 'x') {
                newStudsW = floatSize.studsW + stableSize.studsW;
                newStudsD = Math.max(floatSize.studsD, stableSize.studsD);
            } else {
                newStudsW = Math.max(floatSize.studsW, stableSize.studsW);
                newStudsD = floatSize.studsD + stableSize.studsD;
            }

            // ìƒˆ íŒŒíŠ¸ ì°¾ê¸°
            const key = `${newStudsD}x${newStudsW}`;
            const newPart = STUDS_TO_PART[key];
            if (!newPart) {
                console.log(`ë³‘í•© ë¶ˆê°€: ${key} í¬ê¸°ì˜ ë¸Œë¦­ì´ ì—†ìŒ`);
                return null;
            }

            const newPartSize = MERGE_PART_SIZE[newPart];
            if (!newPartSize) return null;

            // ì•ˆì •ì ì¸ ë¸Œë¦­ ìœ„ì¹˜ì—ì„œ floating ë°©í–¥ìœ¼ë¡œ í™•ì¥
            let newX = stableBrick.x;
            let newZ = stableBrick.z;

            if (axis === 'x') {
                const direction = floatingBrick.x > stableBrick.x ? 1 : -1;
                const addedWidth = floatSize.studsW * 20;
                newX = stableBrick.x + (addedWidth / 2) * direction;
            } else {
                const direction = floatingBrick.z > stableBrick.z ? 1 : -1;
                const addedDepth = floatSize.studsD * 20;
                newZ = stableBrick.z + (addedDepth / 2) * direction;
            }

            const newY = stableBrick.y;

            // ğŸ“Œ ì¶©ëŒ ê²€ì‚¬: ìƒˆ ë¸Œë¦­ì´ ë‹¤ë¥¸ ë¸Œë¦­ê³¼ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸
            const newHalfW = newPartSize.w / 2;
            const newHalfD = newPartSize.d / 2;

            for (const other of allBricks) {
                // ìê¸° ìì‹ (ë³‘í•© ëŒ€ìƒ 2ê°œ)ì€ ì œì™¸
                if (other.id === floatingBrick.id || other.id === stableBrick.id) continue;
                // ì´ë¯¸ ì œê±°ë  ë¸Œë¦­ì€ ì œì™¸
                if (linesToRemove && linesToRemove.has(other.lineIndex)) continue;

                const otherSize = getPartSize(other.part, other.isRotated);
                const otherHalfW = otherSize.w / 2;
                const otherHalfD = otherSize.d / 2;

                // Y(ì¸µ)ê°€ ê°™ì€ì§€ í™•ì¸
                if (Math.abs(other.y - newY) > 1) continue;

                // AABB ì¶©ëŒ ê²€ì‚¬
                const xOverlap = Math.abs(newX - other.x) < (newHalfW + otherHalfW - 1);
                const zOverlap = Math.abs(newZ - other.z) < (newHalfD + otherHalfD - 1);

                if (xOverlap && zOverlap) {
                    console.log(`ì¶©ëŒ! ìƒˆ ë¸Œë¦­(${newX}, ${newZ})ì´ ë¸Œë¦­ #${other.id}(${other.x}, ${other.z})ì™€ ê²¹ì¹¨`);
                    return null;  // ì¶©ëŒ ì‹œ ë³‘í•© ì·¨ì†Œ
                }
            }

            const newColor = stableBrick.color;
            const newLine = `1 ${newColor} ${newX.toFixed(2)} ${newY.toFixed(2)} ${newZ.toFixed(2)} 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 ${newPart}`;

            return {
                newLine,
                removedIds: [floatingBrick.id, stableBrick.id],
                removedLineIndices: [floatingBrick.lineIndex, stableBrick.lineIndex]
            };
        }

        // Floating ë¸Œë¦­ ë³‘í•© ì‹¤í–‰
        function mergeFloatingBricks() {
            if (!lastAnalysisResult) {
                alert('ë¨¼ì € LDRì„ ë¶„ì„í•˜ì„¸ìš”');
                return;
            }

            const ldrContent = document.getElementById('ldrText').value;
            const { bricks, lines } = parseLdrBricks(ldrContent);

            // Floating ë¸Œë¦­ IDë§Œ ì¶”ì¶œ (top_only ì œì™¸ - íŒŒë€ìƒ‰ì€ ë³‘í•© ë¶ˆí•„ìš”)
            const floatingIds = new Set(
                lastAnalysisResult.issues
                    .filter(i => i.type === 'floating')  // floatingë§Œ!
                    .map(i => i.brick_id)
                    .filter(id => id !== null)
            );

            if (floatingIds.size === 0) {
                showMergeResult('âœ… ë³‘í•©í•  Floating ë¸Œë¦­ì´ ì—†ìŠµë‹ˆë‹¤', 'success');
                return;
            }

            console.log(`ë³‘í•© ëŒ€ìƒ (Floating): ${floatingIds.size}ê°œ ë¸Œë¦­`);

            let mergeCount = 0;
            const mergedIds = new Set();
            const linesToRemove = new Set();
            const newLines = [];

            // ê° Floating ë¸Œë¦­ì— ëŒ€í•´ ë³‘í•© ì‹œë„
            for (const floatingId of floatingIds) {
                if (mergedIds.has(floatingId)) continue;

                const floatingBrick = bricks.find(b => b.id === floatingId);
                if (!floatingBrick) continue;

                // ì¸ì ‘ ë¸Œë¦­ ì°¾ê¸° (ì•ˆì •ì ì¸ ë¸Œë¦­ë§Œ!)
                const adjacent = findAdjacentBrick(floatingBrick, bricks, mergedIds, floatingIds);
                if (!adjacent) {
                    console.log(`ë¸Œë¦­ #${floatingId}: ì•ˆì •ì ì¸ ì¸ì ‘ ë¸Œë¦­ ì—†ìŒ`);
                    continue;
                }

                // ë³‘í•© ì‹œë„ (ì¶©ëŒ ê²€ì‚¬ í¬í•¨)
                const mergeResult = mergeTwoBricks(floatingBrick, adjacent.brick, adjacent.axis, bricks, linesToRemove);
                if (!mergeResult) continue;

                console.log(`ë³‘í•©: #${floatingBrick.id} + #${adjacent.brick.id} â†’ ìƒˆ ë¸Œë¦­`);

                mergedIds.add(floatingBrick.id);
                mergedIds.add(adjacent.brick.id);
                mergeResult.removedLineIndices.forEach(i => linesToRemove.add(i));
                newLines.push(mergeResult.newLine);
                mergeCount++;
            }

            if (mergeCount === 0) {
                showMergeResult('âš ï¸ ë³‘í•© ê°€ëŠ¥í•œ ì¸ì ‘ ë¸Œë¦­ì´ ì—†ìŠµë‹ˆë‹¤', 'warning');
                return;
            }

            // ìƒˆ LDR ìƒì„±
            const newLdrLines = [];
            for (let i = 0; i < lines.length; i++) {
                if (!linesToRemove.has(i)) {
                    newLdrLines.push(lines[i]);
                }
            }
            // ìƒˆ ë³‘í•© ë¸Œë¦­ ì¶”ê°€
            newLines.forEach(line => newLdrLines.push(line));

            const newLdr = newLdrLines.join('\n');
            document.getElementById('ldrText').value = newLdr;

            showMergeResult(`âœ… ${mergeCount}ìŒ ë³‘í•© ì™„ë£Œ! ë‹¤ì‹œ ë¶„ì„í•©ë‹ˆë‹¤...`, 'success');

            // ìë™ ì¬ë¶„ì„
            setTimeout(() => analyze(newLdr), 500);
        }

        function showMergeResult(text, type) {
            const resultDiv = document.getElementById('mergeResult');
            const resultText = document.getElementById('mergeResultText');
            resultDiv.style.display = 'block';
            resultText.innerHTML = text;
            resultDiv.style.borderLeft = type === 'success' ? '3px solid #4caf50' : '3px solid #ff9800';
        }

        // ============================================
        // Floating ë¸Œë¦­ ë¶„í•´ ê¸°ëŠ¥ (1x1ë¡œ ìª¼ê°œê¸°)
        // ============================================

        function explodeFloatingBricks() {
            if (!lastAnalysisResult) {
                alert('ë¨¼ì € LDRì„ ë¶„ì„í•˜ì„¸ìš”');
                return;
            }

            const ldrContent = document.getElementById('ldrText').value;
            const { bricks, lines } = parseLdrBricks(ldrContent);

            // Floating ë¸Œë¦­ IDë§Œ ì¶”ì¶œ
            const floatingIds = new Set(
                lastAnalysisResult.issues
                    .filter(i => i.type === 'floating')
                    .map(i => i.brick_id)
                    .filter(id => id !== null)
            );

            if (floatingIds.size === 0) {
                showMergeResult('âœ… ë¶„í•´í•  Floating ë¸Œë¦­ì´ ì—†ìŠµë‹ˆë‹¤', 'success');
                return;
            }

            console.log(`ë¶„í•´ ëŒ€ìƒ: ${floatingIds.size}ê°œ ë¸Œë¦­`);

            let explodeCount = 0;
            const linesToRemove = new Set();
            const newLines = [];

            for (const floatingId of floatingIds) {
                const brick = bricks.find(b => b.id === floatingId);
                if (!brick) continue;

                const size = getPartSize(brick.part, brick.isRotated);

                // ì´ë¯¸ 1x1ì´ë©´ ìŠ¤í‚µ
                if (size.studsW === 1 && size.studsD === 1) continue;

                // ë¸Œë¦­ì„ 1x1ë“¤ë¡œ ë¶„í•´
                const halfW = size.w / 2;
                const halfD = size.d / 2;

                for (let sx = 0; sx < size.studsW; sx++) {
                    for (let sz = 0; sz < size.studsD; sz++) {
                        // ê° 1x1ì˜ ìœ„ì¹˜ ê³„ì‚°
                        const newX = brick.x - halfW + 10 + (sx * 20);
                        const newZ = brick.z - halfD + 10 + (sz * 20);
                        const newY = brick.y;

                        // 1x1 ë¸Œë¦­ (3005.dat) ìƒì„±
                        const newLine = `1 ${brick.color} ${newX.toFixed(2)} ${newY.toFixed(2)} ${newZ.toFixed(2)} 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat`;
                        newLines.push(newLine);
                    }
                }

                linesToRemove.add(brick.lineIndex);
                explodeCount++;
                console.log(`ë¶„í•´: #${brick.id} (${size.studsW}x${size.studsD}) â†’ ${size.studsW * size.studsD}ê°œ 1x1`);
            }

            if (explodeCount === 0) {
                showMergeResult('âš ï¸ ë¶„í•´í•  ë¸Œë¦­ì´ ì—†ìŠµë‹ˆë‹¤ (ì´ë¯¸ 1x1)', 'warning');
                return;
            }

            // ìƒˆ LDR ìƒì„±
            const newLdrLines = [];
            for (let i = 0; i < lines.length; i++) {
                if (!linesToRemove.has(i)) {
                    newLdrLines.push(lines[i]);
                }
            }
            newLines.forEach(line => newLdrLines.push(line));

            const newLdr = newLdrLines.join('\n');
            document.getElementById('ldrText').value = newLdr;

            showMergeResult(`ğŸ’¥ ${explodeCount}ê°œ ë¸Œë¦­ ë¶„í•´ ì™„ë£Œ! ë‹¤ì‹œ ë¶„ì„í•©ë‹ˆë‹¤...`, 'success');

            // ìë™ ì¬ë¶„ì„
            setTimeout(() => analyze(newLdr), 500);
        }

        // ë¶„í•´ ë²„íŠ¼ ì´ë²¤íŠ¸
        document.getElementById('explodeFloatingBtn').addEventListener('click', () => {
            explodeFloatingBricks();
        });

        // ë³‘í•© ë²„íŠ¼ ì´ë²¤íŠ¸
        document.getElementById('mergeFloatingBtn').addEventListener('click', () => {
            mergeFloatingBricks();
        });

        // ============================================
        // ìë™ ìˆ˜ë¦¬ ê¸°ëŠ¥ (ë¶„í•´ â†’ Xì¶• ë³‘í•© â†’ Zì¶• ë³‘í•© ë°˜ë³µ)
        // ============================================

        async function autoRepair() {
            showMergeResult('ğŸ”§ ìë™ ìˆ˜ë¦¬ ì‹œì‘...', 'success');

            let totalMerged = 0;
            let iteration = 0;
            const maxIterations = 10;  // ë¬´í•œë£¨í”„ ë°©ì§€

            while (iteration < maxIterations) {
                iteration++;
                console.log(`=== ìë™ ìˆ˜ë¦¬ ë°˜ë³µ ${iteration} ===`);

                // í˜„ì¬ Floating ìˆ˜ í™•ì¸
                if (!lastAnalysisResult) break;
                const floatingCount = lastAnalysisResult.issues.filter(i => i.type === 'floating').length;
                if (floatingCount === 0) {
                    console.log('Floating ë¸Œë¦­ ì—†ìŒ, ì¢…ë£Œ');
                    break;
                }

                // 1ë‹¨ê³„: ë¶„í•´
                const beforeExplode = document.getElementById('ldrText').value;
                explodeFloatingBricksInternal();
                await sleep(300);

                // 2ë‹¨ê³„: Xì¶• ë³‘í•©
                let xMerged = mergeFloatingBricksWithAxis('x');
                await sleep(300);

                // 3ë‹¨ê³„: Zì¶• ë³‘í•©
                let zMerged = mergeFloatingBricksWithAxis('z');
                await sleep(300);

                totalMerged += xMerged + zMerged;

                // ë³€í™”ê°€ ì—†ìœ¼ë©´ ì¢…ë£Œ
                if (xMerged === 0 && zMerged === 0) {
                    console.log('ë” ì´ìƒ ë³‘í•© ë¶ˆê°€, ì¢…ë£Œ');
                    break;
                }
            }

            showMergeResult(`ğŸ”§ ìë™ ìˆ˜ë¦¬ ì™„ë£Œ! ${iteration}íšŒ ë°˜ë³µ, ${totalMerged}ìŒ ë³‘í•©`, 'success');

            // ìµœì¢… ë¶„ì„
            const finalLdr = document.getElementById('ldrText').value;
            await analyze(finalLdr);
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ë‚´ë¶€ìš© ë¶„í•´ í•¨ìˆ˜ (UI ì—…ë°ì´íŠ¸ ì—†ì´)
        function explodeFloatingBricksInternal() {
            if (!lastAnalysisResult) return;

            const ldrContent = document.getElementById('ldrText').value;
            const { bricks, lines } = parseLdrBricks(ldrContent);

            const floatingIds = new Set(
                lastAnalysisResult.issues
                    .filter(i => i.type === 'floating')
                    .map(i => i.brick_id)
                    .filter(id => id !== null)
            );

            if (floatingIds.size === 0) return;

            const linesToRemove = new Set();
            const newLines = [];

            for (const floatingId of floatingIds) {
                const brick = bricks.find(b => b.id === floatingId);
                if (!brick) continue;

                const size = getPartSize(brick.part, brick.isRotated);
                if (size.studsW === 1 && size.studsD === 1) continue;

                const halfW = size.w / 2;
                const halfD = size.d / 2;

                for (let sx = 0; sx < size.studsW; sx++) {
                    for (let sz = 0; sz < size.studsD; sz++) {
                        const newX = brick.x - halfW + 10 + (sx * 20);
                        const newZ = brick.z - halfD + 10 + (sz * 20);
                        const newLine = `1 ${brick.color} ${newX.toFixed(2)} ${brick.y.toFixed(2)} ${newZ.toFixed(2)} 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat`;
                        newLines.push(newLine);
                    }
                }
                linesToRemove.add(brick.lineIndex);
            }

            if (linesToRemove.size === 0) return;

            const newLdrLines = [];
            for (let i = 0; i < lines.length; i++) {
                if (!linesToRemove.has(i)) newLdrLines.push(lines[i]);
            }
            newLines.forEach(line => newLdrLines.push(line));

            const newLdr = newLdrLines.join('\n');
            document.getElementById('ldrText').value = newLdr;

            // ì¬ë¶„ì„ (ë™ê¸°ì )
            loadLDR(newLdr).then(() => {
                analyzeWithRust(newLdr).then(result => {
                    lastAnalysisResult = result;
                    highlightIssues(result.issues, result.brick_colors || {});
                    updateUI(result);
                }).catch(() => {
                    lastAnalysisResult = judgeBricks(newLdr);
                });
            });
        }

        // íŠ¹ì • ì¶•ìœ¼ë¡œë§Œ ë³‘í•©
        function mergeFloatingBricksWithAxis(preferredAxis) {
            if (!lastAnalysisResult) return 0;

            const ldrContent = document.getElementById('ldrText').value;
            const { bricks, lines } = parseLdrBricks(ldrContent);

            const floatingIds = new Set(
                lastAnalysisResult.issues
                    .filter(i => i.type === 'floating')
                    .map(i => i.brick_id)
                    .filter(id => id !== null)
            );

            if (floatingIds.size === 0) return 0;

            let mergeCount = 0;
            const mergedIds = new Set();
            const linesToRemove = new Set();
            const newLines = [];

            for (const floatingId of floatingIds) {
                if (mergedIds.has(floatingId)) continue;

                const floatingBrick = bricks.find(b => b.id === floatingId);
                if (!floatingBrick) continue;

                // preferredAxisë¡œë§Œ ì¸ì ‘ ë¸Œë¦­ ì°¾ê¸°
                const adjacent = findAdjacentBrick(floatingBrick, bricks, mergedIds, floatingIds, preferredAxis);
                if (!adjacent) continue;

                const mergeResult = mergeTwoBricks(floatingBrick, adjacent.brick, adjacent.axis, bricks, linesToRemove);
                if (!mergeResult) continue;

                mergedIds.add(floatingBrick.id);
                mergedIds.add(adjacent.brick.id);
                mergeResult.removedLineIndices.forEach(i => linesToRemove.add(i));
                newLines.push(mergeResult.newLine);
                mergeCount++;
            }

            if (mergeCount === 0) return 0;

            const newLdrLines = [];
            for (let i = 0; i < lines.length; i++) {
                if (!linesToRemove.has(i)) newLdrLines.push(lines[i]);
            }
            newLines.forEach(line => newLdrLines.push(line));

            const newLdr = newLdrLines.join('\n');
            document.getElementById('ldrText').value = newLdr;

            // ì¬ë¶„ì„
            loadLDR(newLdr).then(() => {
                analyzeWithRust(newLdr).then(result => {
                    lastAnalysisResult = result;
                    highlightIssues(result.issues, result.brick_colors || {});
                    updateUI(result);
                }).catch(() => {
                    lastAnalysisResult = judgeBricks(newLdr);
                });
            });

            return mergeCount;
        }

        // ìë™ ìˆ˜ë¦¬ ë²„íŠ¼ ì´ë²¤íŠ¸
        document.getElementById('autoRepairBtn').addEventListener('click', () => {
            autoRepair();
        });

        // ì´ˆê¸°í™”
        initThree();

        // ì‚¬ìš©ì ì œê³µ ì‹¤ì œ LDR (íšŒì „ ë¸Œë¦­ í¬í•¨)
        const demoLDR = `0 efb42b2a-be35-44e1-80bc-fe891c464be8_pbr.glb (tgt=16)
0 Author: glb_to_ldr_embedded
1 5 -20.00 0.00 -140.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 5 30.00 0.00 -140.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3004.dat
1 5 -50.00 0.00 -130.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3003.dat
1 1 0.00 0.00 -130.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 5 60.00 0.00 -130.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 5 40.00 0.00 -120.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
0 STEP
1 5 -40.00 -24.00 -130.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3002.dat
1 1 0.00 -24.00 -130.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 5 40.00 -24.00 -130.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3002.dat
1 1 0.00 -24.00 -100.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
0 STEP
1 5 -30.00 -48.00 -130.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3003.dat
1 1 0.00 -48.00 -130.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 5 30.00 -48.00 -130.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3003.dat
1 5 -60.00 -48.00 -120.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 5 60.00 -48.00 -120.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 1 -10.00 -48.00 -100.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3004.dat
1 1 20.00 -48.00 -100.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
0 STEP
1 1 -10.00 -72.00 -120.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3004.dat
1 1 20.00 -72.00 -110.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 1 -20.00 -72.00 -100.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 14 0.00 -72.00 -90.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 14 -20.00 -72.00 -80.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 14 20.00 -72.00 -80.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
0 STEP
1 1 10.00 -96.00 -120.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3004.dat
1 1 -20.00 -96.00 -110.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 1 20.00 -96.00 -100.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 14 -10.00 -96.00 -80.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3004.dat
1 14 20.00 -96.00 -80.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
0 STEP
1 1 0.00 -120.00 -130.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 1 -20.00 -120.00 -110.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 1 20.00 -120.00 -110.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 14 -10.00 -120.00 -80.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3004.dat
1 14 20.00 -120.00 -80.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 5 -40.00 -120.00 -70.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 5 40.00 -120.00 -70.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
0 STEP
1 5 0.00 -144.00 -150.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 1 0.00 -144.00 -120.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 1 -20.00 -144.00 -110.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3010.dat
1 1 20.00 -144.00 -110.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3010.dat
1 14 0.00 -144.00 -80.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 5 -40.00 -144.00 -70.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 5 40.00 -144.00 -70.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 5 -20.00 -144.00 -60.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 5 20.00 -144.00 -60.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 1 -40.00 -144.00 80.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 1 40.00 -144.00 80.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 14 0.00 -144.00 90.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3002.dat
1 14 -40.00 -144.00 100.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 14 40.00 -144.00 100.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 1 -40.00 -144.00 120.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 14 -10.00 -144.00 120.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3004.dat
1 14 20.00 -144.00 120.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 1 40.00 -144.00 120.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 14 0.00 -144.00 140.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 1 -20.00 -144.00 150.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 1 20.00 -144.00 150.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 1 0.00 -144.00 160.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
0 STEP
1 5 0.00 -168.00 -150.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 1 -20.00 -168.00 -130.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 1 20.00 -168.00 -130.00 0.000000 0.000000 -1.000000 0.000000 1.000000 0.000000 1.000000 0.000000 0.000000 3004.dat
1 1 -20.00 -168.00 -100.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 1 20.00 -168.00 -100.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 19 -20.00 -168.00 -80.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 14 0.00 -168.00 -80.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat
1 19 20.00 -168.00 -80.00 1.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 1.000000 3005.dat`;

        document.getElementById('ldrText').value = demoLDR;
    </script>
</body>

</html>